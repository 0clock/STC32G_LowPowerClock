C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE OLED
OBJECT MODULE PLACED IN ..\firmware\OLED.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE OLED.c XSMALL OPTIMIZE(9,SPEED) BROWSE DEBUG TABS(2) OBJECT(..\firmwar
                    -e\OLED.obj) 

stmt  level    source

    1          #include "OLED.h"
    2          #include "time.h"
    3          #include "dianzhen.h"
    4          #include "SecondaryMenu.h"
    5          
    6          extern u16 xdata dat00[System_data_num];
    7          extern u16 xdata dat00_low[System_data_num];
    8          extern u8 xdata dat00_flag[System_data_num];
    9          extern u16 xdata dat00_max[System_data_num];
   10          
   11          extern u8  UI_dat[8][16];
   12          
   13          extern u8  UI_TX[3][64];
   14          
   15          extern u8 xdata Time_New[7];
   16          
   17          extern u32 AlarmClock[16];
   18          
   19          u8 xdata SPI_DmaTxBuffer[256]; //_at_ DMA_TX_ADDR;
   20          u8 xdata SPI_DmaTxBuffer2[256]; //_at_ DMA_TX_ADDR;
   21          u8 xdata SPI_DmaRxBuffer[256]; //_at_ DMA_RX_ADDR
   22          
   23          u8 SPI_DMA_USE = 0;
   24          
   25          
   26          u8 SPI_DMA_buy = 0;
   27          
   28          void SPI_init(void)
   29          {
   30   1          P_SW2 = 0x80;
   31   1          SPCTL |=  (1 << 7);//å¿½ç•¥ SS å¼•è„šåŠŸèƒ½ï¼Œä½¿ç”¨ MSTR ç¡®å®šå™¨ä»¶æ˜¯ä¸»æœºè¿˜æ˜¯ä»æœº
   32   1          SPCTL |=  (1 << 6); //ä½¿èƒ½ SPI åŠŸèƒ½
   33   1          SPCTL &= ~(1 << 5); //å…ˆå‘é€/æ¥æ”¶æ•°æ®çš„é«˜ä½ï¼ˆ MSBï¼‰
   34   1          SPCTL |=  (1 << 4); //è®¾ç½®ä¸»æœºæ¨¡å¼
   35   1      
   36   1      //    SPCTL &= ~(1 << 3); //SCLK ç©ºé—²æ—¶ä¸ºä½ç”µå¹³ï¼ŒSCLK çš„å‰æ—¶é’Ÿæ²¿ä¸ºä¸Šå‡æ²¿ï¼Œåæ—¶é’Ÿæ²¿ä
             -¸ºä¸‹é™æ²¿
   37   1      //    SPCTL &= ~(1 << 2); //æ•°æ® SS ç®¡è„šä¸ºä½ç”µå¹³é©±åŠ¨ç¬¬ä¸€ä½æ•°æ®å¹¶åœ¨ SCLK çš„åæ—¶é’Ÿæ²¿æ
             -”¹å˜æ•°æ®
   38   1      
   39   1      //    SPCTL |= (1 << 3); //SCLK ç©ºé—²æ—¶ä¸ºä½ç”µå¹³ï¼ŒSCLK çš„å‰æ—¶é’Ÿæ²¿ä¸ºä¸Šå‡æ²¿ï¼Œåæ—¶é’Ÿæ²¿ä¸
             -ºä¸‹é™æ²¿
   40   1      //    SPCTL |= (1 << 2); //æ•°æ® SS ç®¡è„šä¸ºä½ç”µå¹³é©±åŠ¨ç¬¬ä¸€ä½æ•°æ®å¹¶åœ¨ SCLK çš„åæ—¶é’Ÿæ²¿æ”
             -¹å˜æ•°æ®
   41   1            SPCTL |= 0x0c;
   42   1      
   43   1          //SPCTL = (SPCTL & ~3) | 0;   //SPI æ—¶é’Ÿé¢‘ç‡é€‰æ‹©, 0: 4T, 1: 8T,  2: 16T,  3: 2T
   44   1        
   45   1          SPCTL &= 0xFC;
   46   1          SPCTL |= 0x03;
   47   1      
   48   1          P_SW1 &= 0xf7;     //IOå£åˆ‡æ¢. 0: P1.2/P5.4 P1.3 P1.4 P1.5, 1: P2.2 P2.3 P2.4 P2.5, 2: P5.4 P4.0 P
             -4.1 P4.3, 3: P3.5 P3.4 P3.3 P3.2
   49   1          P_SW1 |= 0x04;
   50   1          //P_SW1 = (P_SW1 & ~(3<<1)) | (1<<1);  //IOå£åˆ‡æ¢. 0: P1.2/P5.4 P1.3 P1.4 P1.5, 1: P2.2 P2.3 P2.4 
             -P2.5, 2: P5.4 P4.0 P4.1 P4.3, 3: P3.5 P3.4 P3.3 P3.2
   51   1          SCK = 1;    // set clock to low initial state
   52   1          SI = 1;
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 2   

   53   1          SPSTAT = 0x80 + 0x40;
   54   1          HSSPI_CFG2 |=0x20;
   55   1      
   56   1      }
   57          
   58          
   59          //========================================================================
   60          // å‡½æ•°: void DMA_Config(void)
   61          // æè¿°: SPI DMA åŠŸèƒ½é…ç½®.
   62          // å‚æ•°: none.
   63          // è¿”å›: none.
   64          // ç‰ˆæœ¬: V1.0, 2021-5-6
   65          //========================================================================
   66          void SPI_DMA_Config(void)
   67          {
   68   1          DMA_SPI_STA = 0x00;
   69   1          DMA_SPI_CFG = 0xC0;   //bit7 1:Enable Interrupt
   70   1          DMA_SPI_AMTH = 0x00;
   71   1          DMA_SPI_AMT = 0xff;   //è®¾ç½®ä¼ è¾“æ€»å­—èŠ‚æ•°ï¼šn+1
   72   1      
   73   1          DMA_SPI_TXAH = (u8)((u16)&SPI_DmaTxBuffer >> 8);  //SPIå‘é€æ•°æ®å­˜å‚¨åœ°å€
   74   1          DMA_SPI_TXAL = (u8)((u16)&SPI_DmaTxBuffer);
   75   1          DMA_SPI_RXAH = (u8)((u16)&SPI_DmaRxBuffer >> 8);  //SPIæ¥æ”¶æ•°æ®å­˜å‚¨åœ°å€
   76   1          DMA_SPI_RXAL = (u8)((u16)&SPI_DmaRxBuffer);
   77   1      
   78   1          //DMA_SPI_CFG2 = 0x01;  //01:P2.2
   79   1          DMA_SPI_CR = 0x81;    //bit7 1:ä½¿èƒ½ SPI_DMA, bit6 1:å¼€å§‹ SPI_DMA ä¸»æœºæ¨¡å¼, bit0 1:æ¸…é™¤ SPI_DM
             -A FIFO
   80   1      }
   81          
   82          
   83          
   84          //========================================================================
   85          // å‡½æ•°: void DMA_Config(void)
   86          // æè¿°: SPI DMA åŠŸèƒ½é…ç½®.
   87          // å‚æ•°: none.
   88          // è¿”å›: none.
   89          // ç‰ˆæœ¬: V1.0, 2021-5-6
   90          //========================================================================
   91          void SPI_DMA()
   92          {
   93   1          if(DMA_SPI_STA)
   94   1          {
   95   2              DMA_SPI_STA = 0;
   96   2              SPSTAT = 0x80 + 0x40;
   97   2              SPI_DMA_buy = 0;
   98   2          }
   99   1      
  100   1      }
  101          void SPI_DMA_delay()
  102          {
  103   1      
  104   1          while(SPI_DMA_buy) //æ¸…0 SPIFå’ŒWCOLæ ‡å¿—
  105   1          {
  106   2          _nop_();
  107   2          _nop_();
  108   2          _nop_();
  109   2          _nop_();
  110   2          PCON = IDL;                                 //MCUè¿›å…¥IDLEæ¨¡å¼
  111   2      //  PCON = PD;                                  //MCUè¿›å…¥æ‰ç”µæ¨¡å¼
  112   2          _nop_();
  113   2          _nop_();
  114   2          _nop_();
  115   2          _nop_();    
  116   2          } 
  117   1        
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 3   

  118   1      }
  119          
  120          void SPI_DMA_TX(u8 num)
  121          {
  122   1      
  123   1          SPI_DMA_delay();
  124   1          SPI_DMA_buy = 1;    
  125   1          DMA_SPI_AMT = num;
  126   1          if(SPI_DMA_USE)
  127   1          {
  128   2             SPI_DMA_USE=0;
  129   2          }
  130   1          else
  131   1          {
  132   2           SPI_DMA_USE=1;
  133   2          }
  134   1          DMA_SPI_CR |= 0x40;
  135   1          
  136   1      }
  137          
  138          
  139          
  140          
  141          void SPI_DMA_switch()
  142          {
  143   1      
  144   1          if(SPI_DMA_USE)
  145   1          {
  146   2              DMA_SPI_TXAH = (u8)((u16)&SPI_DmaTxBuffer2 >> 8); //SPIå‘é€æ•°æ®å­˜å‚¨åœ°å€
  147   2              DMA_SPI_TXAL = (u8)((u16)&SPI_DmaTxBuffer2);              
  148   2          }
  149   1          else
  150   1          {
  151   2              DMA_SPI_TXAH = (u8)((u16)&SPI_DmaTxBuffer >> 8);  //SPIå‘é€æ•°æ®å­˜å‚¨åœ°å€
  152   2              DMA_SPI_TXAL = (u8)((u16)&SPI_DmaTxBuffer);
  153   2          } 
  154   1        
  155   1      }
  156          
  157          
  158          
  159          
  160          
  161          
  162          
  163          
  164          
  165          
  166          void LCD_Writ_Bus(u8 out)
  167          {
  168   1          u16 i = 500;
  169   1          SPI_DMA_delay();
  170   1          SPDAT = out;
  171   1          while(((SPSTAT & 0xC0) == 0)); //æ¸…0 SPIFå’ŒWCOLæ ‡å¿—
  172   1          SPSTAT = 0xC0;
  173   1      }
  174          
  175          void OLED_WrDat(u8 dat)
  176          {
  177   1          SPI_DMA_delay();
  178   1          LCD_Writ_Bus(dat);
  179   1      }
  180          
  181          
  182          
  183          void OLED_WrCmd(u8 dat1)
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 4   

  184          {
  185   1          SPI_DMA_delay();  
  186   1          DC=0;//å†™å‘½ä»¤
  187   1          LCD_Writ_Bus(dat1);
  188   1          DC=1;
  189   1      }
  190          
  191          
  192          void OLED_Fill(u8 bmp_dat)
  193          {
  194   1          u8 y,x;
  195   1          for(y=0; y<8; y++)
  196   1          {
  197   2              OLED_WrCmd((u8)(0xb0+y));
  198   2              OLED_WrCmd(0x00);
  199   2              OLED_WrCmd(0x10);
  200   2              for(x=0; x<X_WIDTH; x++)
  201   2                  OLED_WrDat(bmp_dat);
  202   2          }
  203   1      }
  204          void OLED_Set_Pos(u8 x, u8 y)
  205          {
  206   1          OLED_WrCmd((u8)(0xb0+y));
  207   1          OLED_WrCmd(((x & 0xf0)>>4)|0x10);
  208   1          OLED_WrCmd((x & 0x0f));
  209   1      }
  210          
  211          void OLED_Init(void)
  212          {
  213   1      
  214   1          RST=1;
  215   1          EA=0;
  216   1          //delay_ms(50);
  217   1          Sleep_delay_Time(100);
  218   1          RST=0;
  219   1          //delay_ms(50);
  220   1          Sleep_delay_Time(100);
  221   1          RST=1;
  222   1          //delay_ms(50);
  223   1          Sleep_delay_Time(80);
  224   1          EA = 1;
  225   1          OLED_WrCmd(0xae);//--turn off oled panel  å…³é—­oledé¢æ¿
  226   1          OLED_WrCmd(0x00);//---set low column address   è®¾ç½®ä½åˆ—åœ°å€
  227   1          OLED_WrCmd(0x10);//---set high column address   è®¾ç½®é«˜åˆ—åœ°å€
  228   1          OLED_WrCmd(0x40);//--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)   è®¾ç½®è
             -µ·å§‹è¡Œåœ°å€è®¾ç½®æ˜ å°„RAMæ˜¾ç¤ºèµ·å§‹è¡Œï¼ˆ0x00?0x3Fï¼‰
  229   1          OLED_WrCmd(0x81);//--set contrast controlregister  è®¾ç½®å¯¹æ¯”åº¦æ§åˆ¶å¯„å­˜å™¨
  230   1          OLED_WrCmd(Brightness); // Set SEG Output Current Brightness  è®¾ç½®SEGè¾“å‡ºç”µæµäº®åº¦
  231   1          OLED_WrCmd(0xa0);//--Set SEG/Column Mapping     0xa0å·¦å³åç½® 0xa1æ­£å¸¸
  232   1          OLED_WrCmd(0xc0);//Set COM/Row Scan Direction   0xc0ä¸Šä¸‹åç½® 0xc8æ­£å¸¸
  233   1          OLED_WrCmd(0xa6);//--set normal display     è®¾ç½®æ­£å¸¸æ˜¾ç¤º
  234   1          OLED_WrCmd(0xa8);//--set multiplex ratio(1 to 64)g    è®¾ç½®å¤ç”¨æ¯”ï¼ˆ1åˆ°64ï¼‰g
  235   1          OLED_WrCmd(0x3f);//--1/64 duty
  236   1          OLED_WrCmd(0xd3);//-set display offset  Shift Mapping RAM Counter (0x00~0x3F) è®¾ç½®æ˜¾ç¤ºåç§»é‡ç§»
             -ä½æ˜ å°„RAMè®¡æ•°å™¨ï¼ˆ0x00?0x3Fï¼‰
  237   1          OLED_WrCmd(0x00);//-not offset     ä¸æŠµæ¶ˆ
  238   1          OLED_WrCmd(0xd5);//--set display clock divide ratio/oscillator frequency  è®¾ç½®æ˜¾ç¤ºæ—¶é’Ÿåˆ†é¢‘æ¯”/
             -æŒ¯è¡å™¨é¢‘ç‡
  239   1          OLED_WrCmd(0x80);//--set divide ratio, Set Clock as 100 Frames/Sec    è®¾ç½®åˆ†é¢‘æ¯”ï¼Œå°†æ—¶é’Ÿè®¾ç½
             -®ä¸º100å¸§/ç§’
  240   1          OLED_WrCmd(0xd9);//--set pre-charge period       è®¾å®šé¢„å……ç”µæ—¶é—´
  241   1          OLED_WrCmd(0xf1);//Set Pre-Charge as 15 Clocks & Discharge as 1 Clock å°†é¢„å……ç”µè®¾ç½®ä¸º15ä¸ªæ—¶é’
             -Ÿå¹¶å°†æ”¾ç”µè®¾ç½®ä¸º1ä¸ªæ—¶é’Ÿ
  242   1          OLED_WrCmd(0xda);//--set com pins hardware configuration  è®¾ç½®comå¼•è„šçš„ç¡¬ä»¶é…ç½®
  243   1          OLED_WrCmd(0x12);
  244   1          OLED_WrCmd(0xdb);//--set vcomh
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 5   

  245   1          OLED_WrCmd(0x40);//Set VCOM Deselect Level
  246   1          OLED_WrCmd(0x20);//-Set Page Addressing Mode (0x00/0x01/0x02) è®¾ç½®é¡µé¢å¯»å€æ¨¡å¼
  247   1          OLED_WrCmd(0x02);//
  248   1          OLED_WrCmd(0x8d);//--set Charge Pump enable   è®¾ç½®ç”µè·æ³µå¯ç”¨/ç¦ç”¨
  249   1          OLED_WrCmd(0x10);//--set(0x10) (0x14)æ‰“å¼€
  250   1          OLED_WrCmd(0xa4);// Disable Entire Display On (0xa4/0xa5)ç¦ç”¨æ•´ä¸ªæ˜¾ç¤ºæ‰“å¼€
  251   1          OLED_WrCmd(0xa6);// Disable Inverse Display On (0xa6/a7)ç¦ç”¨åå‘æ˜¾ç¤ºæ‰“å¼€
  252   1          OLED_WrCmd(0xaf);//--turn on oled panel
  253   1          OLED_Fill(0x00); //åˆå§‹æ¸…å±
  254   1          OLED_Set_Pos(0,0);
  255   1      
  256   1      
  257   1      
  258   1      
  259   1      }
  260          
  261          void ZF_8X8(u8 x,u8 y,u8 ee)//
  262          {
  263   1          u8 i;
  264   1          u8 *SPI_dat;
  265   1          if(SPI_DMA_USE)
  266   1          {
  267   2              SPI_dat = SPI_DmaTxBuffer2;           
  268   2          }
  269   1          else
  270   1          {
  271   2              SPI_dat = SPI_DmaTxBuffer; 
  272   2          } 
  273   1          for(i=0; i<8; i++)
  274   1          {
  275   2              SPI_dat[i] = F8x8[ee][i];
  276   2          }
  277   1          OLED_Set_Pos(x,y);
  278   1          SPI_DMA_switch();
  279   1          SPI_DMA_TX(7);    
  280   1          
  281   1          
  282   1          
  283   1          
  284   1      }
  285          void ZF_8X16(u8 x,u8 y,u8 ee)//
  286          {
  287   1          u8 i;
  288   1          u8 k=0;
  289   1          u8 *SPI_dat;
  290   1          if(SPI_DMA_USE)
  291   1          {
  292   2              SPI_dat = SPI_DmaTxBuffer2;           
  293   2          }
  294   1          else
  295   1          {
  296   2              SPI_dat = SPI_DmaTxBuffer; 
  297   2          } 
  298   1          for(i=0; i<8; i++)
  299   1          {
  300   2              SPI_dat[i] = F8x16[ee][i];
  301   2          }
  302   1          OLED_Set_Pos(x,y);
  303   1          SPI_DMA_switch();
  304   1          SPI_DMA_TX(7);  
  305   1      
  306   1          
  307   1          if(SPI_DMA_USE)
  308   1          {
  309   2              SPI_dat = SPI_DmaTxBuffer2;           
  310   2          }
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 6   

  311   1          else
  312   1          {
  313   2              SPI_dat = SPI_DmaTxBuffer; 
  314   2          }     
  315   1          for(; i<16; i++)
  316   1          {
  317   2              SPI_dat[k] = F8x16[ee][i];
  318   2              k++;
  319   2          }    
  320   1          OLED_Set_Pos(x,(u8)(y+1));
  321   1          SPI_DMA_switch();
  322   1          SPI_DMA_TX(7);  
  323   1      
  324   1      
  325   1      
  326   1      
  327   1      
  328   1          
  329   1      }
  330          
  331          
  332          void debug_8x8(int k,u8 x,u8 y)//
  333          {
  334   1          u8 i;
  335   1          u8 x1=x;
  336   1          OLED_Set_Pos(x,y);
  337   1          for(i=0; i<5; i++)
  338   1          {
  339   2              ZF_8X8(x1,y,10);
  340   2              x1=x1+8;
  341   2          }
  342   1          OLED_Set_Pos(x,y);
  343   1          if(k <0)
  344   1          {
  345   2      
  346   2              ZF_8X8(x,y,24);
  347   2              k= k*(-1);
  348   2          }
  349   1          else
  350   1          {
  351   2              ZF_8X8(x,y,10);
  352   2          }
  353   1          x=x+8;
  354   1      
  355   1      
  356   1          ZF_8X8(x,y,(u8)(k / 1000));
  357   1          x=x+8;
  358   1      
  359   1          ZF_8X8(x,y,(u8)((k % 1000)/100));
  360   1          x=x+8;
  361   1      
  362   1          ZF_8X8(x,y,(u8)((k%100)/10));
  363   1          x=x+8;
  364   1          ZF_8X8(x,y,(u8)(k%10));
  365   1      
  366   1      }
  367          
  368          
  369          
  370          
  371          
  372          
  373          
  374          void nian(u16 ee,u8 y)//
  375          {
  376   1          ZF_8X16(0,y,(u8)(ee / 1000));
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 7   

  377   1          ZF_8X16(8,y,(u8)((ee % 1000)/100));
  378   1          ZF_8X16(16,y,(u8)((ee % 100)/10));
  379   1          ZF_8X16(24,y,(u8)(ee % 10));
  380   1          ZF_8X16(32,y,12);
  381   1      }
  382          
  383          void yue_ri(u8 x,u8 ee,bit g)//
  384          {
  385   1          ZF_8X16(x,0,(u8)((ee % 100)/10));
  386   1          ZF_8X16((u8)(x+8),0,(u8)(ee % 10));
  387   1          if(g) ZF_8X16((u8)(x+16),0,12);
  388   1      }
  389          
  390          
  391          
  392          
  393          
  394          
  395          
  396          void shifen(unsigned char t,unsigned char y)//
  397          {
  398   1          unsigned char i;
  399   1          unsigned char j;
  400   1          unsigned char k;
  401   1          for(k=y; k<y+16; k=k+16)
  402   1          {
  403   2              for(j=4; j<8; j++)
  404   2              {
  405   3                  OLED_Set_Pos(k,(u8)(j-1));
  406   3                  for(i=0; i<16; i++)
  407   3                  {
  408   4                      OLED_WrDat(F8x16d[t*4+j-4][i]);
  409   4                  }
  410   3              }
  411   2          }
  412   1      }
  413          
  414          void OLED_16X16(u8 x,u8 y,u8 adde)
  415          {
  416   1          unsigned char i = 0;
  417   1          unsigned char j = 0;  
  418   1          u8 *SPI_dat;
  419   1          adde = adde<<1;
  420   1          for(j=0; j<2; j++)
  421   1          {
  422   2              if(SPI_DMA_USE)
  423   2              {
  424   3                  SPI_dat = SPI_DmaTxBuffer2;           
  425   3              }
  426   2              else
  427   2              {
  428   3                  SPI_dat = SPI_DmaTxBuffer; 
  429   3              }         
  430   2              for(i=0; i<16; i++)
  431   2              {
  432   3                  SPI_dat[i]= F16x16cd[adde][i];
  433   3              }     
  434   2              OLED_Set_Pos(x,y);
  435   2              SPI_DMA_switch();
  436   2              SPI_DMA_TX(15); 
  437   2              adde++;
  438   2              y++;
  439   2          }
  440   1      }
  441          
  442          
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 8   

  443          
  444          
  445          
  446          void OLED_8X8X3_MOV(u8 x,u8 y,u16 adde,u8 devia1,u8 devia2)
  447          {
  448   1          unsigned char i = 0;
  449   1          unsigned char j = 0;
  450   1          if(devia1 > 24) devia1 =0;
  451   1          if(devia2 > 24) devia2 =24;
  452   1          if(x >= 244)
  453   1          {
  454   2              devia1 = 256 - x; 
  455   2              x = 0;  
  456   2          }
  457   1          if(x < 128 && devia1 < 24 && devia2 <= 24)
  458   1          {
  459   2              for(i=0; i<24; i++)
  460   2              {
  461   3                  UI_TX[0][i] = 0x00;
  462   3              }
  463   2      
  464   2              if(adde<10)
  465   2              {
  466   3                  for(i=0; i<8; i++)
  467   3                  {
  468   4                      UI_TX[0][8+i] = F8x8[(adde % 10)][i];
  469   4                  }
  470   3              }
  471   2              else if(adde<100)
  472   2              {
  473   3                  for(i=0; i<8; i++)
  474   3                  {
  475   4                      UI_TX[0][4+i] = F8x8[((adde %100) / 10)][i];
  476   4                  }
  477   3                  for(i=0; i<8; i++)
  478   3                  {
  479   4                      UI_TX[0][12+i] = F8x8[(adde %10)][i];
  480   4                  }
  481   3              }
  482   2              else if(adde<1000)
  483   2              {
  484   3                  for(i=0; i<8; i++)
  485   3                  {
  486   4                      UI_TX[0][i] = F8x8[(adde / 100)][i];
  487   4                  }
  488   3                  for(i=0; i<8; i++)
  489   3                  {
  490   4                      UI_TX[0][8+i] = F8x8[((adde %100) / 10)][i];
  491   4                  }
  492   3                  for(i=0; i<8; i++)
  493   3                  {
  494   4                      UI_TX[0][16+i] = F8x8[(adde %10)][i];
  495   4                  }
  496   3              }
  497   2              OLED_Set_Pos(x,y);
  498   2              for(i=devia1; i<devia2; i++)
  499   2              {
  500   3                  OLED_WrDat(UI_TX[0][i]);
  501   3              }
  502   2          }
  503   1      }
  504          
  505          
  506          
  507          
  508          
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 9   

  509          
  510          void OLED_16X16_MOV(u8 x,u8 y,u8 adde,u8 devia1,u8 devia2)
  511          {
  512   1          unsigned char i = 0;
  513   1          unsigned char j = 0;
  514   1      
  515   1          if(devia1 > 16) devia1 =0;
  516   1          if(devia2 > 16) devia2 =16;
  517   1          if(x >= 248)
  518   1          {
  519   2              devia1 = 256 - x; 
  520   2              x = 0;  
  521   2          }
  522   1        
  523   1          if(x < 128 && devia1 < 16 && devia2 <= 16)
  524   1          {
  525   2              adde = adde<<1;
  526   2              for(j=0; j<2; j++)
  527   2              {
  528   3                  OLED_Set_Pos(x,y);
  529   3                  for(i=devia1; i<devia2; i++)
  530   3                  {
  531   4                      OLED_WrDat(F16x16_position[adde][i]);
  532   4                  }
  533   3                  adde++;
  534   3                  y++;
  535   3              }
  536   2          }
  537   1      }
  538          
  539          void OLED_32X32(u8 x,u8 y,u8 addr,u8 devia1,u8 devia2)
  540          {
  541   1          u8 i = 0;
  542   1          u8 j = 0;
  543   1          u8 k=0; 
  544   1          u8 *SPI_dat;
  545   1          if(x < 128 && devia1 < 32 && devia2 <= 32)
  546   1          {
  547   2              addr = addr<<2;
  548   2              for(j=0; j<4; j++)
  549   2              {
  550   3                  
  551   3                  k=0;
  552   3                  if(SPI_DMA_USE)
  553   3                  {
  554   4                      SPI_dat = SPI_DmaTxBuffer2;           
  555   4                  }
  556   3                  else
  557   3                  {
  558   4                      SPI_dat = SPI_DmaTxBuffer; 
  559   4                  }
  560   3                   for(i=devia1; i<devia2; i++)
  561   3                  {
  562   4                      SPI_dat[k]   = F32x32[addr][i];
  563   4                      k++;
  564   4                  }
  565   3                  OLED_Set_Pos(x,y);
  566   3                  SPI_DMA_switch();
  567   3                  SPI_DMA_TX((u8)(k-1));
  568   3                  addr++;
  569   3                  y++;
  570   3              }
  571   2          }
  572   1      }
  573          
  574          
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 10  

  575          
  576          void OLED_ED()
  577          {
  578   1          OLED_WrCmd(0xae);//--turn off oled panel  å…³é—­oledé¢æ¿
  579   1      
  580   1      }
  581          void OLED_GD()
  582          {
  583   1          unsigned char i;
  584   1          unsigned char j = 0;
  585   1          unsigned char k = 48;
  586   1          unsigned char y = 0;
  587   1          unsigned char t = 0;
  588   1      
  589   1          for(j=0; j<4; j++)
  590   1          {
  591   2              OLED_Set_Pos(k,j);
  592   2              for(i=0; i<32; i++)
  593   2              {
  594   3                  OLED_WrDat(F32x32[j][i]);
  595   3              }
  596   2          }
  597   1          k = 96;
  598   1          for(j=0; j<4; j++)
  599   1          {
  600   2              OLED_Set_Pos(k,j);
  601   2              for(i=0; i<32; i++)
  602   2              {
  603   3                  OLED_WrDat(F32x32[j+4][i]);
  604   3              }
  605   2          }
  606   1          k = 0;
  607   1          for(j=0; j<4; j++)
  608   1          {
  609   2              OLED_Set_Pos(k,j);
  610   2              for(i=0; i<32; i++)
  611   2              {
  612   3                  OLED_WrDat(F32x32[j+36][i]);
  613   3              }
  614   2          }
  615   1      }
  616          
  617          void OLED_Progress_Bar(u16 num,u16 jx)
  618          {
  619   1          u8 i;
  620   1          u8 j;
  621   1          u8 k;
  622   1          j = ((u16)num * 60)/jx;
  623   1          OLED_Set_Pos(18,5);
  624   1          OLED_WrDat(0xff);
  625   1      
  626   1          for(i=0; i<j; i++)
  627   1          {
  628   2              OLED_WrDat(0xff);
  629   2          }
  630   1          k=60-j;
  631   1          for(i=0; i<k; i++)
  632   1          {
  633   2              OLED_WrDat(0x81);
  634   2          }
  635   1      
  636   1          OLED_WrDat(0xff);
  637   1          k = (u8)((num % 1000)/100);
  638   1          if(k!=0)
  639   1          {
  640   2              ZF_8X8(82,5,k);
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 11  

  641   2          }
  642   1          else
  643   1          {
  644   2              ZF_8X8(82,5,0x0A);
  645   2          }
  646   1      
  647   1          j = (u8)((num % 100)/10);
  648   1          if(k==0 && j==0)
  649   1          {
  650   2              ZF_8X8(90,5,0x0A);
  651   2          }
  652   1          else
  653   1          {
  654   2              ZF_8X8(90,5,j);
  655   2          }
  656   1          ZF_8X8(98,5,(u8)(num % 10));
  657   1      
  658   1      }
  659          
  660          void OLED_Region_Fill()
  661          {
  662   1          u8 k;
  663   1          u8 q;
  664   1          u8 i;
  665   1          for(k=0; k<6; k++)
  666   1          {
  667   2              OLED_Set_Pos(16,(u8)(1+k));
  668   2              for(i=0; i<96; i++)
  669   2              {
  670   3                  if(k == 0)
  671   3                  {
  672   4                      q = 0x01;
  673   4                  }
  674   3                  else if(k == 5)
  675   3                  {
  676   4                      q = 0x80;
  677   4                  }
  678   3                  else
  679   3                  {
  680   4                      q=0;
  681   4                  }
  682   3                  if((i == 0) | (i == (95)))
  683   3                  {
  684   4                      q=0xff;
  685   4                  }
  686   3                  OLED_WrDat(q);
  687   3              }
  688   2          }
  689   1      }
  690          
  691          
  692          
  693          //**********************************************************************
  694          //
  695          //    ç¬¬äºŒèœå•åŠŸèƒ½åŒº
  696          //
  697          //**********************************************************************
  698          
  699          
  700          
  701          
  702          void OLED_FZQP(u8 x,u8 y)
  703          {
  704   1          u8 i = 0;
  705   1          OLED_Set_Pos(x,y);
  706   1          for(i=0; i<64; i++)
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 12  

  707   1          {
  708   2              OLED_WrDat(0x00);
  709   2          }
  710   1      
  711   1      }
  712          
  713          
  714          void OLED_16_16V(u8 (*dat)[16],u16 adde,u8 x,u8 y,bit p)
  715          {
  716   1          u8 i = 0;
  717   1          u8 j = 0;
  718   1          u8 k=0; 
  719   1          u8 *SPI_dat;
  720   1          j = adde;
  721   1          adde = adde + 8;
  722   1      
  723   1          k=0;
  724   1          if(SPI_DMA_USE)
  725   1          {
  726   2              SPI_dat = SPI_DmaTxBuffer2;           
  727   2          }
  728   1          else
  729   1          {
  730   2              SPI_dat = SPI_DmaTxBuffer; 
  731   2          }
  732   1          for(; j<adde; j = j + 2)
  733   1          {
  734   2              for(i=0; i<16; i++)
  735   2              {
  736   3                  if(p)
  737   3                  {
  738   4                      SPI_dat[k] = dat[j][i];
  739   4                  }
  740   3                  else
  741   3                  {
  742   4                      SPI_dat[k] = ~dat[j][i];
  743   4                  }
  744   3                  k++;
  745   3              }
  746   2          }
  747   1          OLED_Set_Pos(x,y);
  748   1          SPI_DMA_switch();
  749   1          SPI_DMA_TX((u8)(k-1));    
  750   1      }
  751          
  752          
  753          
  754          
  755          void OLED_16_16Vabc(u8 (*dat)[16],u16 adde,u8 x,u8 y,u8 c,bit jj,u8 Number)
  756          {
  757   1          u8 i = 0;
  758   1          u8 j = 0;
  759   1          u16 t = 0;
  760   1      
  761   1          y = (u8)(y/8);
  762   1          j = adde;
  763   1          adde = adde + Number;
  764   1          if(jj) c = c % 8;
  765   1          if(y < 8)
  766   1          {
  767   2              OLED_Set_Pos(x,y);
  768   2              for(; j<adde; j = j + 2)
  769   2              {
  770   3                  for(i=0; i<16; i++)
  771   3                  {
  772   4                      if(!jj)
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 13  

  773   4                      {
  774   5                          t = dat[j+1][i]*256+dat[j][i];
  775   5                          OLED_WrDat((u8)(t >> c));
  776   5                      }
  777   4                      else
  778   4                      {
  779   5                          t = dat[j][i];
  780   5                          OLED_WrDat((u8)(t << c));
  781   5                      }
  782   4      
  783   4                  }
  784   3      
  785   3              }
  786   2          }
  787   1          y = (u8)(y+1);
  788   1          j = adde  - (Number - 1);
  789   1          adde = adde + 1;
  790   1          if(y < 8)
  791   1          {
  792   2              OLED_Set_Pos(x,y);
  793   2              for(; j<adde; j = j + 2)
  794   2              {
  795   3                  for(i=0; i<16; i++)
  796   3                  {
  797   4                      if(!jj)
  798   4                      {
  799   5                          t = dat[j][i];
  800   5                          OLED_WrDat((u8)(t >> c));
  801   5                      }
  802   4                      else
  803   4                      {
  804   5                          t = dat[j][i]*256+dat[j-1][i];
  805   5                          OLED_WrDat((u8)(t >> (8 - c)));
  806   5                      }
  807   4                  }
  808   3              }
  809   2          }
  810   1          y = (u8)(y+1);
  811   1          j = adde  - Number;
  812   1          if(y < 8)
  813   1          {
  814   2              OLED_Set_Pos(x,y);
  815   2              for(; j<adde; j = j + 2)
  816   2              {
  817   3                  for(i=0; i<16; i++)
  818   3                  {
  819   4                      if(!jj)
  820   4                      {
  821   5      
  822   5                      }
  823   4                      else
  824   4                      {
  825   5                          t = dat[j][i];
  826   5                          OLED_WrDat((u8)(t >> (8 - c)));
  827   5                      }
  828   4                  }
  829   3              }
  830   2      
  831   2      
  832   2          }
  833   1      
  834   1      
  835   1      //u8 i = 0;
  836   1      //    u8 j = 0;
  837   1      //    u16 t = 0;
  838   1      //    u8 k=0; 
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 14  

  839   1      //    u8 *SPI_dat;
  840   1      //    y = (u8)(y/8);
  841   1      //    j = adde;
  842   1      //    adde = adde + Number;
  843   1      //    if(jj) c = c % 8;
  844   1      //    if(y < 8)
  845   1      //    {
  846   1      //        k=0;
  847   1      //        if(SPI_DMA_USE)
  848   1      //        {
  849   1      //            SPI_dat = SPI_DmaTxBuffer2;           
  850   1      //        }
  851   1      //        else
  852   1      //        {
  853   1      //            SPI_dat = SPI_DmaTxBuffer; 
  854   1      //        }
  855   1      //        for(; j<adde; j = j + 2)
  856   1      //        {
  857   1      //            for(i=0; i<16; i++)
  858   1      //            {
  859   1      //                if(!jj)
  860   1      //                {
  861   1      //                    t = dat[j+1][i]*256+dat[j][i];
  862   1      //                    SPI_dat[k]=((u8)(t >> c));
  863   1      //                }
  864   1      //                else
  865   1      //                {
  866   1      //                    t = dat[j][i];
  867   1      //                    SPI_dat[k]=((u8)(t << c));
  868   1      //                }
  869   1      //                k++;
  870   1      //            }
  871   1      
  872   1      //        }
  873   1      //        OLED_Set_Pos(x,y);
  874   1      //        SPI_DMA_switch();
  875   1      //        SPI_DMA_TX((u8)(k-1));          
  876   1      //        
  877   1      //        
  878   1      //        
  879   1      //    }
  880   1      //    y = (u8)(y+1);
  881   1      //    j = adde  - (Number - 1);
  882   1      //    adde = adde + 1;
  883   1      //    if(y < 8)
  884   1      //    {
  885   1      //        k=0;
  886   1      //        if(SPI_DMA_USE)
  887   1      //        {
  888   1      //            SPI_dat = SPI_DmaTxBuffer2;           
  889   1      //        }
  890   1      //        else
  891   1      //        {
  892   1      //            SPI_dat = SPI_DmaTxBuffer; 
  893   1      //        }
  894   1      //        for(; j<adde; j = j + 2)
  895   1      //        {
  896   1      //            for(i=0; i<16; i++)
  897   1      //            {
  898   1      //                if(!jj)
  899   1      //                {
  900   1      //                    t = dat[j][i];
  901   1      //                    SPI_dat[k]=((u8)(t >> c));
  902   1      //                }
  903   1      //                else
  904   1      //                {
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 15  

  905   1      //                    t = dat[j][i]*256+dat[j-1][i];
  906   1      //                    SPI_dat[k]=((u8)(t >> (8 - c)));
  907   1      //                }
  908   1      //                k++;
  909   1      //            }
  910   1      //            
  911   1      //        }
  912   1      //        OLED_Set_Pos(x,y);
  913   1      //        SPI_DMA_switch();
  914   1      //        SPI_DMA_TX((u8)(k-1));  
  915   1      //    }
  916   1      //    y = (u8)(y+1);
  917   1      //    j = adde  - Number;
  918   1      //    if(y < 8)
  919   1      //    {
  920   1      //        k=0;
  921   1      //        if(SPI_DMA_USE)
  922   1      //        {
  923   1      //            SPI_dat = SPI_DmaTxBuffer2;           
  924   1      //        }
  925   1      //        else
  926   1      //        {
  927   1      //            SPI_dat = SPI_DmaTxBuffer; 
  928   1      //        }
  929   1      //        for(; j<adde; j = j + 2)
  930   1      //        {
  931   1      //            for(i=0; i<16; i++)
  932   1      //            {
  933   1      //                if(!jj)
  934   1      //                {
  935   1      //                      SPI_dat[k]=0x00;
  936   1      //                }
  937   1      //                else
  938   1      //                {
  939   1      //                    t = dat[j][i];
  940   1      //                    SPI_dat[k]=((u8)(t >> (8 - c)));
  941   1      //                }
  942   1      //                k++;
  943   1      //            }
  944   1      //            
  945   1      //        }
  946   1      //        OLED_Set_Pos(x,y);
  947   1      //        SPI_DMA_switch();
  948   1      //        SPI_DMA_TX((u8)(k-1));  
  949   1      
  950   1      //    }
  951   1      
  952   1      
  953   1      
  954   1      }
  955          
  956          
  957          u8** TVR(u8 i)
  958          {
  959   1          u8 **pp ;
  960   1      
  961   1          switch (i)
  962   1          {
  963   2          case 0x0000:
  964   2              pp = TVMode_16;//æ ‡å‡†æ¨¡å¼
  965   2              break;
  966   2          case 0x0001:
  967   2              pp = TVMode_16;//æ ‡å‡†æ¨¡å¼
  968   2              break;    
  969   2          case 0x0002 :
  970   2              pp = Environment;//ç¯å¢ƒå‚æ•°
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 16  

  971   2              break;
  972   2          case 0x0003 :
  973   2              pp = Brightness_setting;//äº®åº¦è®¾ç½®
  974   2              break;
  975   2          case 0x0006 :
  976   2              pp = time_set;//æ—¶é—´è®¾ç½®
  977   2              break;
  978   2          case 0x0007 :
  979   2              pp = AlarmClock_set;//é—¹é’Ÿè®¾ç½®
  980   2              break;
  981   2          
  982   2          
  983   2          
  984   2          case 0x000A :
  985   2              pp = Sound_setting;//å£°éŸ³è®¾ç½®
  986   2              break;
  987   2          case 0x000C :
  988   2              pp = Power_Options;//ç”µæºç®¡ç†
  989   2              break;
  990   2          case 0x000E :
  991   2              pp = System_Information;//ç³»ç»Ÿä¿¡æ¯
  992   2              break;
  993   2          
  994   2          
  995   2          case 0x0040 :
  996   2              pp = System_Information_data;//ç³»ç»Ÿä¿¡æ¯æ•°æ®
  997   2              break;
  998   2      
  999   2          
 1000   2          
 1001   2          
 1002   2          case 0x0060 :
 1003   2              pp = UI_dat;//ç³»ç»Ÿä¿¡æ¯æ•°æ®
 1004   2              break;      
 1005   2          
 1006   2          
 1007   2          case 0x0080 :
 1008   2              pp = F8x16d;
 1009   2              break;
 1010   2      
 1011   2          default:
 1012   2              pp = TVMode_16;
 1013   2              break;
 1014   2      
 1015   2          }
 1016   1          return pp;
 1017   1      
 1018   1      }
 1019          
 1020          
 1021          
 1022          
 1023          
 1024          
 1025          
 1026          
 1027          void OLED_16_16V2(u8 (*dat)[16],u16 adde,u8 x,u8 y,bit p)
 1028          {
 1029   1      
 1030   1          OLED_16_16V(dat,adde,x,y,p);
 1031   1          adde = adde + 1;
 1032   1          OLED_16_16V(dat,adde,x,(u8)(y+1),p);
 1033   1          OLED_FZQP(0,5);
 1034   1      
 1035   1      }
 1036          
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 17  

 1037          
 1038          void OLED_Mean2_fill(u8 p,u8 a)
 1039          {
 1040   1          u8 i;
 1041   1          u8 j;
 1042   1          if(p<=8)
 1043   1          {
 1044   2              for(j = 0; j <p ; j++)
 1045   2              {
 1046   3                  for(i = 0; i <16 ; i++)
 1047   3                  {
 1048   4                      UI_dat[j][i] = a;
 1049   4                  }
 1050   3              }
 1051   2          }
 1052   1      }
 1053          
 1054          void OLED_Mean2_fill2(u8 a)
 1055          {
 1056   1          u8 i;
 1057   1          u8 j;
 1058   1          u8 (*pa)[16];
 1059   1      
 1060   1          if(a>0)
 1061   1          {
 1062   2              pa = KG_K;
 1063   2          }
 1064   1          else
 1065   1          {
 1066   2              pa = KG_G;
 1067   2      
 1068   2          }
 1069   1          for(j = 0; j <4 ; j++)
 1070   1          {
 1071   2              for(i = 0; i <16 ; i++)
 1072   2              {
 1073   3                  UI_dat[j+4][i] = pa[j][i];
 1074   3              }
 1075   2          }
 1076   1          OLED_Mean2_fill(4,0);
 1077   1      }
 1078          
 1079          
 1080          
 1081          void OLED_AlarmClock_ZQ(u8 a)
 1082          {
 1083   1          u8 i;
 1084   1          u8 j;
 1085   1          u8 k=6;
 1086   1          u32 dat=0;
 1087   1        
 1088   1          dat = AlarmClock[a];
 1089   1        
 1090   1        
 1091   1          if(dat & 0x00000001) k=8;
 1092   1          for(j = 0; j <2 ; j++)
 1093   1          {
 1094   2              for(i = 0; i <16 ; i++)
 1095   2              {
 1096   3                  UI_dat[j][i] = DSW_1[j+k][i];
 1097   3              }
 1098   2          }
 1099   1          
 1100   1          
 1101   1          dat = dat>>1;
 1102   1          i = (u8)(dat & 0x00000003);
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 18  

 1103   1          k=0;
 1104   1          if(i == 0)
 1105   1          {
 1106   2              k=4;
 1107   2          }
 1108   1          else if(i == 3)
 1109   1          {
 1110   2              k=2;
 1111   2          }
 1112   1          for(j = 6; j <8 ; j++)
 1113   1          {
 1114   2              for(i = 0; i <16 ; i++)
 1115   2              {
 1116   3                  UI_dat[j][i] = DSW_1[k][i];
 1117   3              }
 1118   2              k++;
 1119   2          }   
 1120   1          
 1121   1              for(i = 0; i <4 ; i++)
 1122   1              {
 1123   2                  UI_dat[2][i] = 0x00;
 1124   2                  UI_dat[3][i] = 0x00;          
 1125   2              } 
 1126   1              for(i = 12; i <16 ; i++)
 1127   1              {
 1128   2                  UI_dat[2][i] = 0x00;
 1129   2                  UI_dat[3][i] = 0x00;
 1130   2              }
 1131   1          
 1132   1      
 1133   1              for(i = 0; i <8 ; i++)
 1134   1              {
 1135   2                  UI_dat[2][i+4] = F8x16[a][i];
 1136   2              } 
 1137   1      
 1138   1              for(i = 0; i <8 ; i++)
 1139   1              {
 1140   2                  UI_dat[3][i+4] = F8x16[a][i+8];
 1141   2              }   
 1142   1          
 1143   1          
 1144   1          
 1145   1          for(j = 4; j <6 ; j++)
 1146   1          {
 1147   2              for(i = 0; i <16 ; i++)
 1148   2              {
 1149   3                  UI_dat[j][i] = 0;
 1150   3              }
 1151   2          }   
 1152   1          
 1153   1          
 1154   1      }
 1155          
 1156          
 1157          
 1158          
 1159          
 1160          
 1161          void OLED_Mean2_fill_num_10X(u8 k,u8 a)
 1162          {
 1163   1          OLED_Mean2_fill_num((u8)(a+1),(u8)(k % 10),F8x16);
 1164   1          OLED_Mean2_fill_num(a,(u8)(k / 10),F8x16);  
 1165   1      }
 1166          
 1167          void OLED_AlarmClock_ZH(u8 a)
 1168          {
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 19  

 1169   1          u32 dat = 0;
 1170   1          u8 k=0;
 1171   1      
 1172   1          dat = AlarmClock[a];
 1173   1        
 1174   1          dat = dat>>3;
 1175   1        
 1176   1          k = (u8)(dat & 0x0000003f);
 1177   1          OLED_Mean2_fill_num_10X(k,6); 
 1178   1          OLED_Mean2_fill_num(5,20,F8x16);
 1179   1        
 1180   1        
 1181   1        
 1182   1          dat = dat>>6;
 1183   1          k = (u8)(dat & 0x0000003f);
 1184   1          OLED_Mean2_fill_num_10X(k,3);  
 1185   1          OLED_Mean2_fill_num(2,20,F8x16);
 1186   1        
 1187   1        
 1188   1          dat = dat>>6;
 1189   1          k = (u8)(dat & 0x0000001f); 
 1190   1          OLED_Mean2_fill_num_10X(k,0);   
 1191   1        
 1192   1      }
 1193          
 1194          
 1195          
 1196          
 1197          u8 numlongGet(u16 a)
 1198          {
 1199   1          if(a >= 10000)
 1200   1          {
 1201   2              a = 5;
 1202   2          }
 1203   1          else if(a >= 1000)
 1204   1          {
 1205   2              a = 4;
 1206   2          }
 1207   1          else if(a >= 100)
 1208   1          {
 1209   2              a = 3;
 1210   2          }
 1211   1          else if(a >= 10)
 1212   1          {
 1213   2              a = 2;
 1214   2          }
 1215   1          else
 1216   1          {
 1217   2              a = 1;
 1218   2          }
 1219   1          return a;
 1220   1      }
 1221          
 1222          
 1223          void OLED_Mean2_fill_num(u8 a,u8 b,u8 (*dat)[16])
 1224          {
 1225   1          u8 i;
 1226   1          u8 j;
 1227   1          u8 c=0;
 1228   1          j = (a >> 1) << 1;
 1229   1          c = (a % 2) << 3;
 1230   1      
 1231   1          for(i = 0; i <8 ; i++)
 1232   1          {
 1233   2              UI_dat[j][i+c] = dat[b][i];
 1234   2      
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 20  

 1235   2          }
 1236   1          j = j + 1;
 1237   1          for(i = 0; i <8 ; i++)
 1238   1          {
 1239   2              UI_dat[j][i+c] = dat[b][i+8];
 1240   2      
 1241   2          }
 1242   1      }
 1243          
 1244          
 1245          void OLED_Mean2_fill_num2(u16 a)
 1246          {
 1247   1          u8 i = 0;
 1248   1          u8 k;
 1249   1          u16 dat = 0;
 1250   1          u8 xsd =0;
 1251   1          u8 fh = 0;
 1252   1          u8 adde = 7;
 1253   1      
 1254   1      
 1255   1        
 1256   1          
 1257   1          
 1258   1      
 1259   1      
 1260   1          dat = dat00[a];
 1261   1          
 1262   1          
 1263   1        
 1264   1          xsd = (u8)(dat00_max[a] >>14);
 1265   1          fh = (u8)((dat00_max[a] >>12) & 0x0003);
 1266   1          k =  (u8)((dat00_max[a] >>8) & 0x000F);
 1267   1      
 1268   1          OLED_Mean2_fill(8,0);
 1269   1      
 1270   1      
 1271   1          if(fh > 0)
 1272   1          {
 1273   2              for(i = 0; i < fh; i++)
 1274   2              {
 1275   3                  OLED_Mean2_fill_num(adde,(u8)(k-i),F8x16_unit);
 1276   3                  adde--;
 1277   3              }
 1278   2          }
 1279   1      
 1280   1          k = numlongGet(dat);
 1281   1      
 1282   1      
 1283   1      
 1284   1          if(xsd)
 1285   1          {
 1286   2              if(k <= xsd)
 1287   2              {
 1288   3                  k = xsd + 2;
 1289   3              }
 1290   2              else
 1291   2              {
 1292   3                  k = k + 1;
 1293   3              }
 1294   2          }
 1295   1      
 1296   1      
 1297   1          for(i = 0; i < k; i++)
 1298   1          {
 1299   2              if(i == xsd && xsd != 0)
 1300   2              {
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 21  

 1301   3                  OLED_Mean2_fill_num(adde,0x0B,F8x16);
 1302   3                  adde--;
 1303   3              }
 1304   2              else
 1305   2              {
 1306   3                  OLED_Mean2_fill_num(adde,(u8)(dat%10),F8x16);
 1307   3                  if(adde > 0) adde--;
 1308   3                  dat = dat/10;
 1309   3              }
 1310   2          }
 1311   1      
 1312   1      
 1313   1      }
 1314          
 1315          
 1316          
 1317          
 1318          
 1319          void shifen_dh_z(u8 t,u8 x,u8 yy,u16 y,u8  limit)//
 1320          {
 1321   1      //    u8 i;
 1322   1      //    OLED_Set_Pos(x,yy);
 1323   1      //    for(i=0; i<16; i++)
 1324   1      //    {
 1325   1      //        OLED_WrDat((F8x16d[(t+y/8) %  limit][i] >> (y % 8)) | (F8x16d[(t+1+y/8) %  limit][i] << 8-(y % 
             -8)));
 1326   1      //    }
 1327   1          u8 i;
 1328   1          u8 *SPI_dat;
 1329   1          if(SPI_DMA_USE)
 1330   1          {
 1331   2              SPI_dat = SPI_DmaTxBuffer2;           
 1332   2          }
 1333   1          else
 1334   1          {
 1335   2              SPI_dat = SPI_DmaTxBuffer; 
 1336   2          }
 1337   1          for(i=0; i<16; i++)
 1338   1          {
 1339   2              SPI_dat[i] = (F8x16d[(t+y/8) %  limit][i] >> (y % 8)) | (F8x16d[(t+1+y/8) %  limit][i] << 8-(y % 
             -8));
 1340   2          }
 1341   1          OLED_Set_Pos(x,yy);
 1342   1          SPI_DMA_switch();
 1343   1          SPI_DMA_TX((u8)(i-1));    
 1344   1      }
 1345          
 1346          void shifen_dh(u8 x,u8 yy,u16 y,u8  limit)//
 1347          {
 1348   1          unsigned char i;
 1349   1          for(i=0; i<4; i++)
 1350   1          {
 1351   2              shifen_dh_z(i,x,(u8)(yy+i),y, limit);
 1352   2      
 1353   2          }
 1354   1      }
 1355          
 1356          
 1357          
 1358          
 1359          void IU_Battery_Icon_S_1(u8 x,u8 y)
 1360          {
 1361   1          u8 j,k;
 1362   1      
 1363   1          k = (u8)(dat00[0x00E5] /1000);
 1364   1          if(k!=0)
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 22  

 1365   1          {
 1366   2              ZF_8X8((u8)(x+24),y,k);
 1367   2          }
 1368   1          else
 1369   1          {
 1370   2              ZF_8X8((u8)(x+24),y,0x0A);
 1371   2          }
 1372   1      
 1373   1          j = (u8)((dat00[0x00E5] % 1000)/100);
 1374   1          if(k==0 && j==0)
 1375   1          {
 1376   2              ZF_8X8((u8)(x+32),y,0x0A);
 1377   2          }
 1378   1          else
 1379   1          {
 1380   2              ZF_8X8((u8)(x+32),y,j);
 1381   2          }
 1382   1          ZF_8X8((u8)(x+40),y,(u8)((dat00[0x00E5] % 100)/10));
 1383   1      
 1384   1      
 1385   1      
 1386   1      
 1387   1      
 1388   1      }
 1389          
 1390          
 1391          
 1392          
 1393          void IU_Battery_Icon_S(u8 x,u8 y)
 1394          {
 1395   1          u16 a = 0;
 1396   1          u8 j = 0;
 1397   1          u8 i;
 1398   1          u8 k=0;
 1399   1          a =  dat00[0x00E5]/83;
 1400   1          OLED_Set_Pos((u8)(x+8),y);
 1401   1      
 1402   1          for(i=0; i<16; i++)
 1403   1          {
 1404   2              if(i == 0)
 1405   2              {
 1406   3                  OLED_WrDat(0xFf);
 1407   3              }
 1408   2              else if(i == 1)
 1409   2              {
 1410   3                  OLED_WrDat(0x81);
 1411   3              }
 1412   2              else if(i <= 12)
 1413   2              {
 1414   3                  if((a + 1) >= i)
 1415   3                  {
 1416   4                      OLED_WrDat(0xBD);
 1417   4                  }
 1418   3                  else
 1419   3                  {
 1420   4                      OLED_WrDat(0x81);
 1421   4                  }
 1422   3              }
 1423   2              else if(i <= 13)
 1424   2              {
 1425   3                  if(a == 12)
 1426   3                  {
 1427   4                      OLED_WrDat(0x99);
 1428   4                  }
 1429   3                  else
 1430   3                  {
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 23  

 1431   4                      OLED_WrDat(0x81);
 1432   4                  }
 1433   3              }
 1434   2              else if(i <= 14)
 1435   2              {
 1436   3                  OLED_WrDat(0xC3);
 1437   3              }
 1438   2              else if(i <= 15)
 1439   2              {
 1440   3                  OLED_WrDat(0x3C);
 1441   3              }
 1442   2          }
 1443   1      
 1444   1          IU_Battery_Icon_S_1(x,y);
 1445   1          if(dat00[0x00E1])
 1446   1          {
 1447   2              ZF_8X8(x,y,0x0B);
 1448   2          }
 1449   1          else
 1450   1          {
 1451   2              ZF_8X8(x,y,0x0A);
 1452   2          }
 1453   1      
 1454   1      }
 1455          
 1456          
 1457          //*************************ç”µæ± ç•Œé¢UI********************
 1458          
 1459          
 1460          void IU_Battery_cheek()
 1461          {
 1462   1          u8 i =0;
 1463   1          for(i=2; i<6; i++)
 1464   1          {
 1465   2              ZF_8X8(120,i,16);
 1466   2          }
 1467   1      
 1468   1          for(i=2; i<6; i++)
 1469   1          {
 1470   2              ZF_8X8(96,i,16);
 1471   2          }
 1472   1      
 1473   1          OLED_Set_Pos(104,1);
 1474   1          for(i=0; i<2; i++)
 1475   1          {
 1476   2              OLED_WrDat(0x3c);
 1477   2          }
 1478   1          for(i=0; i<12; i++)
 1479   1          {
 1480   2              OLED_WrDat(0x3f);
 1481   2          }
 1482   1          for(i=0; i<2; i++)
 1483   1          {
 1484   2              OLED_WrDat(0x3c);
 1485   2          }
 1486   1      
 1487   1          OLED_Set_Pos(104,6);
 1488   1          for(i=0; i<16; i++)
 1489   1          {
 1490   2              OLED_WrDat(0x3c);
 1491   2          }
 1492   1          ZF_8X8(96,1,18);
 1493   1          ZF_8X8(120,1,19);
 1494   1          ZF_8X8(96,6,21);
 1495   1          ZF_8X8(120,6,20);
 1496   1      
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 24  

 1497   1      
 1498   1      
 1499   1          ZF_8X16(80,5,25);
 1500   1          ZF_8X16(88,5,26);
 1501   1      
 1502   1          ZF_8X16(8,5,11);
 1503   1          ZF_8X16(28,5,27);
 1504   1      
 1505   1      }
 1506          
 1507          
 1508          
 1509          
 1510          
 1511          void IU_16x8_Fill(u8 x,u8 y,u8 t)
 1512          {
 1513   1          u8 i;
 1514   1          OLED_Set_Pos(x,y);
 1515   1          for(i=0; i<16; i++)
 1516   1          {
 1517   2              OLED_WrDat(t);
 1518   2          }
 1519   1      }
 1520          
 1521          
 1522          
 1523          void IU_Battery_cheek_renovate_count(u16 a,u8 x,u8 y,u8 t)
 1524          {
 1525   1          u8 b,p;
 1526   1          p = t + 8;
 1527   1          if(a>=p)
 1528   1          {
 1529   2              b = 0xff;
 1530   2          }
 1531   1          else if( a > t && a <= p)
 1532   1          {
 1533   2              b = 0xff;
 1534   2              b = b << (p-a);
 1535   2          }
 1536   1          else
 1537   1          {
 1538   2              b = 0;
 1539   2          }
 1540   1          IU_16x8_Fill(x,y,b);
 1541   1      
 1542   1      
 1543   1      }
 1544          
 1545          
 1546          void IU_Battery_cheek_renovate()
 1547          {
 1548   1          u16 a = 0;
 1549   1          u8 b = 0;
 1550   1          u8 i ;
 1551   1          a =  (u8)((u32)dat00[0x00E5]*100/3125);
 1552   1      
 1553   1          //miao((u8)dat00[0x00E2]);
 1554   1      
 1555   1          if(dat00[0x00E2])
 1556   1          {
 1557   2              IU_Battery_cheek_renovate_count(a,104,2,24);
 1558   2              IU_Battery_cheek_renovate_count(a,104,3,16);
 1559   2              IU_Battery_cheek_renovate_count(a,104,4,8);
 1560   2              IU_Battery_cheek_renovate_count(a,104,5,0);
 1561   2      
 1562   2          }
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 25  

 1563   1          else
 1564   1          {
 1565   2              IU_16x8_Fill(104,2,0);
 1566   2              IU_16x8_Fill(104,5,0);
 1567   2              OLED_Set_Pos(104,3);
 1568   2              ZF_8X8(104,3,22);
 1569   2              ZF_8X8(112,3,23);
 1570   2              ZF_8X8(104,4,23);
 1571   2              ZF_8X8(112,4,22);
 1572   2          }
 1573   1      
 1574   1          if(dat00[0x00E1])
 1575   1          {
 1576   2      
 1577   2              if((u8)(Time_New[0] % 6) == 0)
 1578   2              {
 1579   3                  ZF_8X16(72,3,10);
 1580   3                  ZF_8X16(80,3,10);
 1581   3              }
 1582   2              ZF_8X16((u8)(24 + (Time_New[0] % 6) * 8),3,10);
 1583   2              ZF_8X16((u8)(32 + (Time_New[0] % 6) * 8),3,23);
 1584   2              ZF_8X16((u8)(40 + (Time_New[0] % 6) * 8),3,24);
 1585   2          }
 1586   1          else
 1587   1          {
 1588   2              if(dat00_low[0x00E1] != dat00[0x00E1])
 1589   2              {
 1590   3                  OLED_Set_Pos(24,3);
 1591   3                  for(i = 0; i<56; i++)
 1592   3                  {
 1593   4                      OLED_WrDat(0x00);
 1594   4                  }
 1595   3                  OLED_Set_Pos(24,4);
 1596   3                  for(i = 0; i<56; i++)
 1597   3                  {
 1598   4                      OLED_WrDat(0x00);
 1599   4                  }
 1600   3              }
 1601   2          }
 1602   1      
 1603   1      
 1604   1          if(dat00[0x00E4]>=100)
 1605   1          {
 1606   2              ZF_8X16(56,5,(u8)((dat00[0x00E4]%1000)/100));
 1607   2          }
 1608   1          else
 1609   1          {
 1610   2              ZF_8X16(56,5,10);
 1611   2          }
 1612   1      
 1613   1          if(dat00[0x00E4]>=10)
 1614   1          {
 1615   2              ZF_8X16(64,5,(u8)((dat00[0x00E4]%100)/10));
 1616   2          }
 1617   1          else
 1618   1          {
 1619   2              ZF_8X16(64,5,10);
 1620   2          }
 1621   1          ZF_8X16(72,5,(u8)(dat00[0x00E4]%10));
 1622   1      
 1623   1      
 1624   1          ZF_8X16(0,5,(u8)((dat00[0x00E3]/1000)));
 1625   1          ZF_8X16(12,5,(u8)((dat00[0x00E3]%1000)/100));
 1626   1          ZF_8X16(20,5,(u8)((dat00[0x00E3]%100)/10));
 1627   1      
 1628   1          IU_Battery_Icon_S_1(76,7);
C251 COMPILER V5.60.0,  OLED                                                               24/04/24  23:59:19  PAGE 26  

 1629   1      }
 1630          
 1631          void OLED_16_16V2a()
 1632          {
 1633   1          u8 i=0;
 1634   1          delay_ms(200);
 1635   1          delay_ms(200);;
 1636   1          delay_ms(200);
 1637   1          delay_ms(200);
 1638   1          delay_ms(200);
 1639   1          delay_ms(200);
 1640   1          delay_ms(200);
 1641   1          delay_ms(200);
 1642   1      
 1643   1      
 1644   1      }
 1645          
 1646          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =     21224     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       768     ------
  xdata-const size     =    ------     ------
  edata size           =         2         56
  bit size             =    ------          4
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        10     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
