#include "DATA.h"
#include "UI.h"
#include "OLED.h"
#include "time.h"
#include "UART1.h"
#include "INS5699S.h"
#include "SleepMode.h"


/****************************** 控制寄存器组 ***********************************/
volatile u16 dat00[System_data_num]=
{
//0程序系统参数
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//1UI光标寄存器组
    0,0,0,0,0x8000,0x8000,0,0x000A,0x000A,0,0,0,0,0,0,0,

//2标准模式寄存器组
    6,0,40,10,10,2,1,0,0,0,0,0,0,0,0,0,

//3休眠模式寄存器组
    7,5,0,0,0,1,0,0,0,0,0,0,0,0,0,0,

//4环境信息寄存器组
    0x0007,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//5亮度设置寄存器组
    0x0008,0x00FF,0,0,0x0008,0x0005,0x0001,0x000f,0,0,0,0,0,0,0,0,

//6指南针寄存器组
    0,0,0,0,0,0,0,0,0,1,6,0,0,0,0,0,

//7水平尺寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//8时间设置寄存器组
    8,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,

//9闹钟寄存器组
    9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//10增量闹钟寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//11秒表寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//12声音设置寄存器组
    0x0003,0,20,1,0,0,0,0,0,0,0,0,0,0,0,0,

//13手电筒设置寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//14电源管理寄存器组
    0x0006,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//15系统设置寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//16系统信息寄存器组
    0x000C,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//17工厂模式寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

};



volatile u16 dat00_low[System_data_num]=
{
//0程序系统参数
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//1UI光标寄存器组
    0,0,0,0,0x8000,0x8000,0,0x000A,0x000A,0,0,0,0,0,0,0,

//2标准模式寄存器组
    6,0,40,10,10,2,1,0,0,0,0,0,0,0,0,0,

//3休眠模式寄存器组
    7,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//4环境信息寄存器组
    0x0007,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//5亮度设置寄存器组
    0x0008,0x00FF,0,0,0x0008,0x0005,0x0001,0x000f,0,0,0,0,0,0,0,0,

//6指南针寄存器组
    0,0,0,0,0,0,0,0,0,1,6,0,0,0,0,0,

//7水平尺寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//8时间设置寄存器组
    8,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,

//9闹钟寄存器组
    9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//10增量闹钟寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//11秒表寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//12声音设置寄存器组
    0x0003,0,20,1,0,0,0,0,0,0,0,0,0,0,0,0,

//13手电筒设置寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//14电源管理寄存器组
    0x0006,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//15系统设置寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//16系统信息寄存器组
    0x000C,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//17工厂模式寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

};

volatile u8 xdata dat00_flag[System_data_num]= {0};

volatile u16 xdata dat00_max[System_data_num]=
{
//0程序系统参数
    0,0,0,0,0,0,0,0,60,0,0,0,0,0,0,0,

//1UI光标寄存器组
    0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//2标准模式寄存器组
    0XFF,0x1001,0x110C,0x1103,0x1103,0x1103,0xFF,0,0,0,0,0,0,0,0,0,

//3休眠模式寄存器组
    0XFF,0x110C,0x1103,0x1103,0x1103,0x1001,0x1001,0xFF,0,0,0,0,0,0,0,0,

//4环境信息寄存器组
    0XFF,0xA38D,0x948D,0x378D,0x2C8D,0x2C8D,0x2C8D,0x2C8D,0,0,0,0,0,0,0,0,

//5亮度设置寄存器组
    0XFF,0x0A,0x0B,0x1001,0x001C,0x001C,0x001C,0x001C,0x0B,0,0,0,0,0,0,0,

//6指南针寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//7水平尺寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//8时间设置寄存器组
    0xff,0x00ff,0x000F,0x000F,0x000E,0x0010,0x0013,0x0011,0x0012,0x1001,0x1001,0x1001,0x1103,0,0,0,

//9闹钟寄存器组
    0xff,0x000F,0x000F,0x000E,0x0018,0x0017,0x1001,0x1001,0x110C,0x1001,0,0,0,0,0,0,

//10增量闹钟寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//11秒表寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//12声音设置寄存器组
    0XFF,0x1001,0x210C,0x1001,0,0,0,0,0,0,0,0,0,0,0,0,

//13手电筒设置寄存器组
    0xFF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//14电源管理寄存器组
    0xFF,0x0081,0x0081,0xDA8D,0x298D,0x548D,0x1001,0,0,0,0,0,0,0,0,0,

//15系统设置寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//16系统信息寄存器组
    0XFF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

//17工厂模式寄存器组
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

};
//最大值寄存器（低6位）：
//0:0~0xffff
//1:0~1
//2:0~10
//3:0~100
//4:0~1000
//5:0~10000
//6:0~0xff
//7:0~0x80
//8:0~0x7F
//9:0~UI_main_branchnum 主菜单分支数-1
//10:1~0xFF
//11:0~3
//12:1~100
//13:0~0xFFFF
//14:0~23
//15:0~59
//16:0~6
//17:1~12

//(18)19:0~99
//(19)18:1~31

//20:1~30
//21:1~29
//22:1~28

//23:0~12
//24:0~31
//25:0~30
//26:0~29
//27:0~28
//28:1~15



//7bit=1:不可修改
//6bit=1:不显示数值

//最大值寄存器（高8位）：

//bit15 + bit14 2位：小数点位数
//bit13 + bit12 2位：单位符号个数
//bit11 ~ bit8 4位：单位符号开始地址





/****************************** UI图形缓冲存器组 ***********************************/
u8  UI_dat[8][16] = {0};

u8  UI_TX[3][64] = {0};



/****************************** 睡眠寄存器组 ***********************************/
u16  Sleep_Queue[Sleep_queue_num]= {0};
u16  Sleep_Queue_count = 0;
u16  Sleep_Queue_count_target = 0;



u16  Sleep_Queue_task[Sleep_queue_num]= {0};



/****************************** 时间寄存器组 ***********************************/
//年 月 日 周 时 分 秒
u8 Time_New[7] = {0,0,0,0,0,0,0};
u8 Time_Low[7] = {0,0,0,0,0,0,0};
//u8 xdata Time_int[7] = {0x50,0x30,0x09,0x01,0x27,0x02,0x23};
u8 xdata Time_int[7] = {0x00,0x12,0x02,0x10,0x25,0x04,0x24};
//u8 xdata Time_int[7] = {0x01,0x00,0x00,0x80,0x01,0x02,0x23};





//========================================================================
// 函数: void Array_Initialization_8(u8 *array_name,u16 array_num)
// 描述: 初始化一个数组
// 参数: 
// 返回: 
// 版本: V1.0 2023.02.05
//========================================================================
void Array_Initialization_8(u8 *array_name,u16 array_num)
{
    u16 i=0;
    for(i=0; i<array_num; i++)
    {
        array_name[i]=0;
    }
}
//========================================================================
// 函数: void Array_Initialization_16(u16 *array_name,u16 array_num)
// 描述: 初始化一个数组
// 参数: 
// 返回: 
// 版本: V1.0 2023.02.05
//========================================================================
void Array_Initialization_16(u16 *array_name,u16 array_num)
{
    u16 i=0;
    for(i=0; i<array_num; i++)
    {
        array_name[i]=0;
    }
}

//========================================================================
// 函数: void Array_Initialization_()
// 描述: 初始化数组
// 参数: 
// 返回: 
// 版本: V1.0 2023.02.05
//========================================================================
void Array_Initialization_()
{
    Array_Initialization_16(Sleep_Queue,Sleep_queue_num);
    Array_Initialization_16(Sleep_Queue_task,Sleep_queue_num);
    Array_Initialization_8(Time_Low,7);
    Array_Initialization_8(Time_New,7);
    Array_Initialization_8(dat00_flag,System_data_num);
}






//========================================================================
// 函数: void array_fill(u16 *array_name,u16 array_num,u16 array_dat,u16 w)
// 描述: 从数组的[array_num]开始装填array_dat，装填w个
// 参数: 
// 返回: 
// 版本: V1.0 2023.02.05
//========================================================================
void array_fill(u16 *array_name,u16 array_num,u16 array_dat,u16 w)
{
    u16 j = 0;
    array_num = array_num + w;
    for(j=w; j<array_num; j++)
    {
        array_name[j]=array_dat;
    }
}
//========================================================================
// 函数: u16 RFF()
// 描述: 检测一个数组里面不为0的部分长到哪里
// 参数: 
// 返回: 数组有效长度
// 版本: V1.0 2023.02.05
//========================================================================
u16 RFF()
{
    u16 i = 0;
    u16 b = 0;
    u16 a = 0;
    for(i = 7; i<Sleep_queue_num; i = i + 8)
    {
        if(Sleep_Queue[i] == 0)
        {
            b = i;
            i = 200;
        }
    }

    for(i = b-7; i<=b; i++)
    {
        if(Sleep_Queue[i] == 0)
        {
            a = i;
            i = 200;
        }
    }
    return a;

}

//========================================================================
// 函数: void SleepQueue_MoveLeft(u16 p)
// 描述: 睡眠任务队列和睡眠任务时间队列左移p位(使用快速算法)
// 参数: 
// 返回: 
// 版本: V1.0 2023.02.05
//========================================================================
void SleepQueue_MoveLeft(u16 p)
{
    u16 j = 0;
    u16 h =0;
    h = RFF();
    for(j=0; j<h; j++)
    {
        Sleep_Queue[j]=Sleep_Queue[j+p];
        Sleep_Queue_task[j]=Sleep_Queue_task[j+p];
    }
    Sleep_Queue[h]=0;
    Sleep_Queue_task[h]=0;
}



//========================================================================
// 函数: void SleepQueue_MoveLeft2
// 描述: 睡眠任务队列和睡眠任务时间队列左移一位
// 参数: 
// 返回: 
// 版本: V1.0 2023.02.05
//========================================================================
void SleepQueue_MoveLeft2()
{
    u16 j = 0;
    u16 h =0;
    h = Sleep_queue_num -2;
    for(j=0; j<h; j++)
    {
        Sleep_Queue[j]=Sleep_Queue[j+1];
        Sleep_Queue_task[j]=Sleep_Queue_task[j+1];
    }
    Sleep_Queue[h]=0;
    Sleep_Queue_task[h]=0;
}





//========================================================================
// 函数: void SleepQueue_behindW(u16 time,u16 num)
// 描述: 在队尾插入时间time和任务num
// 参数: 
// 返回: 
// 版本: V1.0 2023.02.05
//========================================================================
void SleepQueue_behindW(u16 time,u16 num)
{
    u16 j = 0;
    j = RFF();

    Sleep_Queue[j]=time;
    Sleep_Queue_task[j]=num;

}


//========================================================================
// 函数: void SleepQueue_aheadW1(u16 time,u16 num,u16 f)
// 描述: 在队列第f个插入时间time和任务num
// 参数: 
// 返回: 
// 版本: V1.0 2023.02.05
//========================================================================
void SleepQueue_aheadW1(u16 time,u16 num,u16 f)
{
    u16 i = 0;
    u16 k = 0;
    u16 j = 0;
    for(i=f; i<Sleep_queue_num; i++)
    {
        j = j + Sleep_Queue[i];


        if(Sleep_Queue[i] != 0 && time < j)
        {
            for(k= RFF(); k>i; k--)
            {
                Sleep_Queue[k]=Sleep_Queue[k-1];
                Sleep_Queue_task[k]	 = Sleep_Queue_task[k-1];
            }
            Sleep_Queue[i] = time - ( j - Sleep_Queue[i+1]);
            Sleep_Queue_task[i]	 = num;
            Sleep_Queue[i+1] = Sleep_Queue[i+1] - Sleep_Queue[i];
            i  = 200;
        }
        else if(Sleep_Queue[i] != 0 && time == j)
        {
            Sleep_Queue_task[i]	 |= num;
            i  = 200;
        }
        else if(Sleep_Queue[i] == 0)
        {
            Sleep_Queue[i] = time - j;
            Sleep_Queue_task[i]	 = num;
            i  = 200;
        }
    }
}

//========================================================================
// 函数: void fast_SleepQueue_aheadW1(u16 dat,u16 task,u8 num)
// 描述: 快速插入算法 在队首快速插入num 个时间dat和任务task
// 参数: 
// 返回: 
// 版本: V1.0 2023.02.05
//========================================================================
void fast_SleepQueue_aheadW1(u16 dat,u16 task,u8 num)
{
    u16 a =0;
    u16 i =0;
    u16 j =0;
    a = RFF();//获得数组有数值的长度
    if(a == 0)
    {
        array_fill(Sleep_Queue,num,dat,0);
        array_fill(Sleep_Queue_task,num,task,0);
    }
    else
    {
        array_fill(Sleep_Queue,num,dat,a);
        array_fill(Sleep_Queue_task,num,task,a);
        for(i = 0; i < a; i++) //共处理 n 个数据
        {
            j = j + Sleep_Queue[i];
            SleepQueue_aheadW1(j,Sleep_Queue_task[i],a);
        }
    }
    if(a) SleepQueue_MoveLeft(a);
}



//========================================================================
// 函数: u16 data_GetMax(u16 dat)
// 描述: 获取光标指向的数据的最大值
// 参数: 
// 返回: 光标指向的数据的最大值
// 版本: V1.0 2023.02.05
//========================================================================
u16 data_GetMax(u16 dat)
{
    u16 k =0;
    dat = dat00_max[dat];
    dat &= 0x003F;
    switch (dat)
    {
    case 0x00 :
        k=0xffff;
        break;
    case 0x01 :
        k=1;
        break;
    case 0x02 :
        k=10;
        break;
    case 0x03 :
        k=100;
        break;
    case 0x04 :
        k=1000;
        break;
    case 0x05 :
        k=10000;
        break;
    case 0x06 :
        k=0xff;
        break;
    case 0x07 :
        k=0x80;
        break;
    case 0x08 :
        k=0x7f;
        break;
    case 0x09 :
        k=UI_main_branchnum;
        break;
    case 0x0A :
        k=0xff;
        break;
    case 0x0B :
        k=0x03;
        break;
    case 0x0C :
        k=100;
        break;
    case 0x0D :
        k=0xFFFF;
        break;
    case 0x0E :
        k=0x0017;
        break;
    case 0x0F :
        k=0x003B;
        break;
    case 0x10 :
        k=0x0006;
        break;
    case 0x11 :
        k=12;
        break;
    case 0x12 : k=99; break;
    case 0x13 : k=31;  break;
    case 0x14 : k=30; break;
    case 0x15 : k=29;  break;
    case 0x16 : k=28;  break;
    case 0x17 : k=12;  break;
    case 0x18 : k=31;  break;		
    case 0x19 : k=30;  break;		
    case 0x1A : k=29;  break;		
    case 0x1B : k=28;  break;	
    case 0x1C : k=15;  break;	


		
    case 0xFF : k=0;   break;
    default:    k=0;   break;
//**********************************************
    }
    return k;
}

//========================================================================
// 函数: u16 data_GetMin(u16 dat)
// 描述: 获取光标指向的数据的最小值
// 参数: 
// 返回: 光标指向的数据的最小值
// 版本: V1.0 2023.02.05
//========================================================================
u16 data_GetMin(u16 dat)
{
    u16 k =0;
    dat = dat00_max[dat];
    dat &= 0x003F;

    if(dat == 0x0A || dat == 0x0C || dat == 0x11 || dat == 0x13 || dat == 0x14 || dat == 0x15 || dat == 0x16 || dat == 0x1C  )
    {
        k=1;
    }
    return k;
}



//========================================================================
// 函数: void data00_Change(u16 address,u16 add)
// 描述: 数据+1或者-1溢出会自动变成最大或者最小
// 参数: 
// 返回: 
// 版本: V1.0 2023.02.05
//========================================================================
void data00_Change(u16 address,u16 add)
{
    if(add)
    {
        if(dat00[address] >= data_GetMax(address))
        {
            dat00[address] = data_GetMin(address);
        }
        else
        {
            dat00[address]++;
        }
    }
    else
    {
        if(dat00[address] <= data_GetMin(address))
        {
            dat00[address] = data_GetMax(address);
        }
        else
        {
            dat00[address]--;
        }

    }
    dat00_flag[address] = 1;
}





u16 GET_SC()  //获取目前是调用0x0?0组标号
{
    u16 dat =0;
    dat = (dat00[0x10] + 1) * 16;
    return dat;
}

u16 GET_SCdat() //获取目前是调用0x0?0组 的值（当前组寄存器个数）
{
    return dat00[GET_SC()];
}


u16 GET_GBdat()   //获取目前是调用0x0?0组 的光标 的值
{
    return dat00[GET_SC() + 0x0f];
}

u16 GET_SCdat3() //获取目前是调用0x0?0组 的 指向
{
    return GET_GBdat() + 1 + GET_SC();
}





//========================================================================
// 函数: u8 BCD_to_X10(u8 a)
// 描述: 输入BCD格式的数据，返回普通格式的数据
// 参数: 
// 返回: 返回普通格式的数据
// 版本: V1.0 2023.02.05
//========================================================================
u8 BCD_to_X10(u8 a)
{
    a = (a / 16)*10 +(a%16);
    return a;
}

//========================================================================
// 函数: u8 BCD_to_X10(u8 a)
// 描述: 输入普通格式的数据，返回BCD格式的数据
// 参数: 
// 返回: 返回BCD格式的数据
// 版本: V1.0 2023.02.05
//========================================================================
u8 X10_to_BCD(u16 a)
{
    a = (a / 10)*16 + (a%10);
    return (u8)a;
}


//========================================================================
// 函数: u8 GET_WEEK(u8 a)
// 描述: 输入RTC读回的原始数据，返回星期
// 参数: 
// 返回: 返回星期
// 版本: V1.0 2023.02.05
//========================================================================
u8 GET_WEEK(u8 a)
{
    u8 i=0;
    u8 b=0x01;
    for(i=0; i<8; i++)
    {
        if(a == b) break;
        b = b <<1;
    }

    return i;
}
//========================================================================
// 函数: u8 GET_WEEK(u8 a)
// 描述: 输入星期数据，返回RTC的星期格式
// 参数: 
// 返回: 返回RTC的星期格式
// 版本: V1.0 2023.02.05
//========================================================================
u8 SET_WEEK(u16 a)
{
    u8 i=0;
    u8 b=0x01;

    for(i=0; i<a; i++)
    {
        b = b <<1;
    }

    return b;
}




//========================================================================
// 函数: void GET_time_c()
// 描述: 获取时间的正常格式，进入修改时间会用到
// 参数: 
// 返回: 
// 版本: V1.0 2023.02.05
//========================================================================
void GET_time_c()
{
    u8 i = 0;
    dat00[0x0082] = BCD_to_X10(Time_New[0]);
    dat00[0x0083] = BCD_to_X10(Time_New[1]);
    dat00[0x0084] = BCD_to_X10(Time_New[2]);
    dat00[0x0086] = BCD_to_X10(Time_New[4]);
    dat00[0x0087] = BCD_to_X10(Time_New[5]);
    dat00[0x0088] = BCD_to_X10(Time_New[6]);
    dat00[0x0085] = GET_WEEK(Time_New[3]);
    for(i=0; i<7; i++)
    {
        dat00_low[0x0082+i] = dat00[0x0082+i];
    }
}

//========================================================================
// 函数: void SET_time_c()
// 描述: 将正常格式的时间转换为BCD码
// 参数: 
// 返回: 
// 版本: V1.0 2023.02.05
//========================================================================
void SET_time_c()
{
    Time_int[0] = X10_to_BCD(dat00[0x0082]);
    Time_int[1] = X10_to_BCD(dat00[0x0083]);
    Time_int[2] = X10_to_BCD(dat00[0x0084]);
    Time_int[3] = SET_WEEK(dat00[0x0085]);
    Time_int[4] = X10_to_BCD(dat00[0x0086]);
    Time_int[5] = X10_to_BCD(dat00[0x0087]);
    Time_int[6] = X10_to_BCD(dat00[0x0088]);
    //dat00[0x0084] = GET_WEEK(Time_New[3]);
}


//========================================================================
// 函数: u16 Date_restrictions1(u16 year,u16 moon,u16 day_addr,u16 max)
// 描述: 输入年月，判断日是不是符合要求，如果不符合则强制修改
// 参数: 
// 返回: 
// 版本: V1.0 2023.02.05
//========================================================================
u16 Date_restrictions1(u16 year,u16 moon,u16 day_addr,u16 max)
{
    u16 num = 0;
	  u16 add = 0;
	  if(max == 0x0094) add = 5;
    if( (moon ==  4) ||  (moon ==  6) ||  (moon ==  9)||  (moon ==  11))
    {
        dat00_max[max] = 0x0014 + add;
        num = 30;
    }
    else if(moon ==  2)
    {
        if((year % 4) ==0)//闰年
        {
            dat00_max[max] = 0x0015 + add;
            num = 29;
        }
        else
        {
            dat00_max[max] = 0x0016 + add;
            num = 28;
        }
    }
    else
    {
        dat00_max[max] = 0x0013 + add;
			  num = 31;
    }
    if( day_addr > num) day_addr = num;
		
    return day_addr;
}








