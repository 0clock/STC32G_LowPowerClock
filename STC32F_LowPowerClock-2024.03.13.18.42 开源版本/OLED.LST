C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE OLED
OBJECT MODULE PLACED IN OLED.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE OLED.c XSMALL OPTIMIZE(9,SPEED) BROWSE DEBUG TABS(2) 

stmt  level    source

    1          #include "OLED.h"
    2          #include "time.h"
    3          #include "dianzhen.h"
    4          #include "SecondaryMenu.h"
    5          
    6          extern u16 dat00[System_data_num];
    7          extern u16 dat00_low[System_data_num];
    8          extern u8 xdata dat00_flag[System_data_num];
    9          extern u16 xdata dat00_max[System_data_num];
   10          
   11          extern u8 UI_dat[8][16];
   12          
   13          extern u8 UI_TX[3][64];
   14          
   15          extern u8 Time_New[7];
   16          
   17          extern u32 AlarmClock[16];
   18          
   19          extern u16 Battery_PE_Low;
   20          
   21          u8 xdata SPI_DmaTxBuffer[256];  //_at_ DMA_TX_ADDR;
   22          u8 xdata SPI_DmaTxBuffer2[256]; //_at_ DMA_TX_ADDR;
   23          u8 xdata SPI_DmaRxBuffer[256];  //_at_ DMA_RX_ADDR
   24          
   25          u8 SPI_DMA_USE = 0;
   26          
   27          u8 SPI_DMA_buy = 0;
   28          
   29          extern u8 OLED_InverseDisplay;
   30          extern u16 Sleep36;
   31          
   32          //========================================================================
   33          // å‡½æ•°: void SPI_init(void)
   34          // æè¿°: SPIåˆå§‹åŒ–ï¼ŒSTCå®˜æ–¹ä¾‹ç¨‹æ”¹çš„
   35          // å‚æ•°:
   36          // è¿”å›:
   37          // ç‰ˆæœ¬: V1.0  2023.02.05
   38          //========================================================================
   39          void SPI_init(void)
   40          {
   41   1          P_SW2 = 0x80;
   42   1          SPCTL |= (1 << 7);  // å¿½ç•¥ SS å¼•è„šåŠŸèƒ½ï¼Œä½¿ç”¨ MSTR ç¡®å®šå™¨ä»¶æ˜¯ä¸»æœºè¿˜æ˜¯ä»æœº
   43   1          SPCTL |= (1 << 6);  // ä½¿èƒ½ SPI åŠŸèƒ½
   44   1          SPCTL &= ~(1 << 5); // å…ˆå‘é€/æ¥æ”¶æ•°æ®çš„é«˜ä½ï¼ˆ MSBï¼‰
   45   1          SPCTL |= (1 << 4);  // è®¾ç½®ä¸»æœºæ¨¡å¼
   46   1      
   47   1          //    SPCTL &= ~(1 << 3); //SCLK ç©ºé—²æ—¶ä¸ºä½ç”µå¹³ï¼ŒSCLK çš„å‰æ—¶é’Ÿæ²¿ä¸ºä¸Šå‡æ²¿ï¼Œåæ—¶é’Ÿ
             -æ²¿ä¸ºä¸‹é™æ²¿
   48   1          //    SPCTL &= ~(1 << 2); //æ•°æ® SS ç®¡è„šä¸ºä½ç”µå¹³é©±åŠ¨ç¬¬ä¸€ä½æ•°æ®å¹¶åœ¨ SCLK çš„åæ—¶é’Ÿ
             -æ²¿æ”¹å˜æ•°æ®
   49   1      
   50   1          //    SPCTL |= (1 << 3); //SCLK ç©ºé—²æ—¶ä¸ºä½ç”µå¹³ï¼ŒSCLK çš„å‰æ—¶é’Ÿæ²¿ä¸ºä¸Šå‡æ²¿ï¼Œåæ—¶é’Ÿæ
             -²¿ä¸ºä¸‹é™æ²¿
   51   1          //    SPCTL |= (1 << 2); //æ•°æ® SS ç®¡è„šä¸ºä½ç”µå¹³é©±åŠ¨ç¬¬ä¸€ä½æ•°æ®å¹¶åœ¨ SCLK çš„åæ—¶é’Ÿæ
             -²¿æ”¹å˜æ•°æ®
   52   1          SPCTL |= 0x0c;
   53   1      
   54   1          // SPCTL = (SPCTL & ~3) | 0;   //SPI æ—¶é’Ÿé¢‘ç‡é€‰æ‹©, 0: 4T, 1: 8T,  2: 16T,  3: 2T
   55   1      
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 2   

   56   1          SPCTL &= 0xFC;
   57   1          SPCTL |= 0x03;
   58   1      
   59   1          P_SW1 &= 0xf7; // IOå£åˆ‡æ¢. 0: P1.2/P5.4 P1.3 P1.4 P1.5, 1: P2.2 P2.3 P2.4 P2.5, 2: P5.4 P4.0 P4.1
             - P4.3, 3: P3.5 P3.4 P3.3 P3.2
   60   1          P_SW1 |= 0x04;
   61   1          // P_SW1 = (P_SW1 & ~(3<<1)) | (1<<1);  //IOå£åˆ‡æ¢. 0: P1.2/P5.4 P1.3 P1.4 P1.5, 1: P2.2 P2.3 P2.4
             - P2.5, 2: P5.4 P4.0 P4.1 P4.3, 3: P3.5 P3.4 P3.3 P3.2
   62   1          SCK = 1; // set clock to low initial state
   63   1          SI = 1;
   64   1          SPSTAT = 0x80 + 0x40;
   65   1          HSSPI_CFG2 |= 0x20;
   66   1          SPI_DMA_buy = 0;
   67   1      }
   68          
   69          //========================================================================
   70          // å‡½æ•°: void DMA_Config(void)
   71          // æè¿°: SPI DMA åŠŸèƒ½é…ç½®.STCå®˜æ–¹ä¾‹ç¨‹
   72          // å‚æ•°: none.
   73          // è¿”å›: none.
   74          // ç‰ˆæœ¬: V1.0, 2021-5-6
   75          //========================================================================
   76          void SPI_DMA_Config(void)
   77          {
   78   1          DMA_SPI_STA = 0x00;
   79   1          DMA_SPI_CFG = 0xC0; // bit7 1:Enable Interrupt
   80   1          DMA_SPI_AMTH = 0x00;
   81   1          DMA_SPI_AMT = 0xff; // è®¾ç½®ä¼ è¾“æ€»å­—èŠ‚æ•°ï¼šn+1
   82   1      
   83   1          DMA_SPI_TXAH = (u8)((u16)&SPI_DmaTxBuffer >> 8); // SPIå‘é€æ•°æ®å­˜å‚¨åœ°å€
   84   1          DMA_SPI_TXAL = (u8)((u16)&SPI_DmaTxBuffer);
   85   1          DMA_SPI_RXAH = (u8)((u16)&SPI_DmaRxBuffer >> 8); // SPIæ¥æ”¶æ•°æ®å­˜å‚¨åœ°å€
   86   1          DMA_SPI_RXAL = (u8)((u16)&SPI_DmaRxBuffer);
   87   1      
   88   1          // DMA_SPI_CFG2 = 0x01; //01:P2.2
   89   1          DMA_SPI_CR = 0x81; // bit7 1:ä½¿èƒ½ SPI_DMA, bit6 1:å¼€å§‹ SPI_DMA ä¸»æœºæ¨¡å¼, bit0 1:æ¸…é™¤ SPI_DM
             -A FIFO
   90   1      }
   91          
   92          //========================================================================
   93          // å‡½æ•°: void SPI_DMA()
   94          // æè¿°: SPI å‘é€
   95          // å‚æ•°:
   96          // è¿”å›:
   97          // ç‰ˆæœ¬: V1.0, 2021-5-6
   98          //========================================================================
   99          void SPI_DMA()
  100          {
  101   1          if (DMA_SPI_STA) // DMA æ­£å¿™å°±è·³è¿‡
  102   1          {
  103   2              DMA_SPI_STA = 0;
  104   2              SPSTAT = 0x80 + 0x40;
  105   2              SPI_DMA_buy = 0;
  106   2          }
  107   1      }
  108          //========================================================================
  109          // å‡½æ•°: void SPI_DMA_delay()
  110          // æè¿°: ç­‰å¾…SPI DMAå‘é€å®Œæˆï¼Œå¹¶è¿›å…¥IDLEæ¨¡å¼
  111          // å‚æ•°:
  112          // è¿”å›:
  113          // ç‰ˆæœ¬: V1.0, 2021-5-6
  114          //========================================================================
  115          void SPI_DMA_delay()
  116          {
  117   1      
  118   1          while (SPI_DMA_buy) // ç­‰DMAå‘å®Œ
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 3   

  119   1          {
  120   2              _nop_();
  121   2              _nop_();
  122   2              _nop_();
  123   2              _nop_();
  124   2              PCON = IDL; // MCUè¿›å…¥IDLEæ¨¡å¼
  125   2              _nop_();
  126   2              _nop_();
  127   2              _nop_();
  128   2              _nop_();
  129   2          }
  130   1      }
  131          //========================================================================
  132          // å‡½æ•°: void SPI_DMA_TX(u8 num)
  133          // æè¿°: SPI DMA å‘é€æ•°æ®ï¼ŒåŒæ—¶åˆ‡æ¢ç©ºé—²åŒºåŸŸæ ‡å¿—ä½
  134          // å‚æ•°: num ï¼š å‘é€num+1ä¸ªå­—èŠ‚
  135          // è¿”å›:
  136          // ç‰ˆæœ¬: V1.0, 2021-5-6
  137          //========================================================================
  138          void SPI_DMA_TX(u8 num)
  139          {
  140   1      
  141   1          SPI_DMA_delay();
  142   1          SPI_DMA_buy = 1;
  143   1          DMA_SPI_AMT = num;
  144   1          if (SPI_DMA_USE)
  145   1          {
  146   2              SPI_DMA_USE = 0;
  147   2          }
  148   1          else
  149   1          {
  150   2              SPI_DMA_USE = 1;
  151   2          }
  152   1          DMA_SPI_CR |= 0x40;
  153   1      }
  154          
  155          //========================================================================
  156          // å‡½æ•°: void SPI_DMA_switch()
  157          // æè¿°: æ ¹æ®æ¢ç©ºé—²åŒºåŸŸæ ‡å¿—ä½åˆ‡æ¢è£…å¡«çš„DMAåœ°å€
  158          // å‚æ•°:
  159          // è¿”å›:
  160          // ç‰ˆæœ¬: V1.0, 2023-12-15
  161          //========================================================================
  162          void SPI_DMA_switch()
  163          {
  164   1      
  165   1          if (SPI_DMA_USE)
  166   1          {
  167   2              DMA_SPI_TXAH = (u8)((u16)&SPI_DmaTxBuffer2 >> 8); // SPIå‘é€æ•°æ®å­˜å‚¨åœ°å€
  168   2              DMA_SPI_TXAL = (u8)((u16)&SPI_DmaTxBuffer2);
  169   2          }
  170   1          else
  171   1          {
  172   2              DMA_SPI_TXAH = (u8)((u16)&SPI_DmaTxBuffer >> 8); // SPIå‘é€æ•°æ®å­˜å‚¨åœ°å€
  173   2              DMA_SPI_TXAL = (u8)((u16)&SPI_DmaTxBuffer);
  174   2          }
  175   1      }
  176          
  177          //========================================================================
  178          // å‡½æ•°: void LCD_Writ_Bus(u8 out)
  179          // æè¿°: SPIå†™ä¸€ä¸ªå­—èŠ‚
  180          // å‚æ•°: dat éœ€è¦å‘çš„æ•°æ®
  181          // è¿”å›:
  182          // ç‰ˆæœ¬: V1.0, 2021-12-15
  183          //========================================================================
  184          void LCD_Writ_Bus(u8 out)
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 4   

  185          {
  186   1          u16 i = 500;
  187   1          SPI_DMA_delay();
  188   1          SPDAT = out;
  189   1          while (((SPSTAT & 0xC0) == 0))
  190   1              ; // æ¸…0 SPIFå’ŒWCOLæ ‡å¿—
  191   1          SPSTAT = 0xC0;
  192   1      }
  193          //========================================================================
  194          // å‡½æ•°: void OLED_WrDat(u8 dat)
  195          // æè¿°: SPIå†™ä¸€ä¸ªå­—èŠ‚
  196          // å‚æ•°: dat éœ€è¦å‘çš„æ•°æ®
  197          // è¿”å›:
  198          // ç‰ˆæœ¬: V1.0, 2021-12-15
  199          //========================================================================
  200          void OLED_WrDat(u8 dat)
  201          {
  202   1          SPI_DMA_delay();
  203   1          LCD_Writ_Bus(dat);
  204   1      }
  205          
  206          //========================================================================
  207          // å‡½æ•°: void OLED_WrDat(u8 dat)
  208          // æè¿°: SPIå†™ä¸€ä¸ªå‘½ä»¤å­—èŠ‚
  209          // å‚æ•°: dat éœ€è¦å‘çš„æ•°æ®
  210          // è¿”å›:
  211          // ç‰ˆæœ¬: V1.0, 2021-12-15
  212          //========================================================================
  213          void OLED_WrCmd(u8 dat1)
  214          {
  215   1          SPI_DMA_delay();
  216   1          DC = 0; // å†™å‘½ä»¤
  217   1          LCD_Writ_Bus(dat1);
  218   1          DC = 1;
  219   1      }
  220          
  221          //========================================================================
  222          // å‡½æ•°: void OLED_Fill(u8 bmp_dat)
  223          // æè¿°: OLEDæ•´å±å¡«å……
  224          // å‚æ•°: bmp_dat éœ€å¡«å……çš„æ•°æ®
  225          // è¿”å›:
  226          // ç‰ˆæœ¬: V1.0, 2021-12-15
  227          //========================================================================
  228          void OLED_Fill(u8 bmp_dat)
  229          {
  230   1          u8 y, x;
  231   1          for (y = 0; y < 8; y++)
  232   1          {
  233   2              OLED_WrCmd((u8)(0xb0 + y));
  234   2              OLED_WrCmd(0x00);
  235   2              OLED_WrCmd(0x10);
  236   2              for (x = 0; x < X_WIDTH; x++)
  237   2                  OLED_WrDat(bmp_dat);
  238   2          }
  239   1      }
  240          
  241          //========================================================================
  242          // å‡½æ•°: void OLED_Set_Pos(u8 x, u8 y)
  243          // æè¿°: è®¾ç½®OLEDå¡«å……æ•°æ®ä½ç½®,ä¸­æ™¯ä¾‹ç¨‹
  244          // å‚æ•°: x:Xåæ ‡  y:yåæ ‡
  245          // è¿”å›:
  246          // ç‰ˆæœ¬: V1.0, 2021-12-15
  247          //========================================================================
  248          void OLED_Set_Pos(u8 x, u8 y)
  249          {
  250   1          OLED_WrCmd((u8)(0xb0 + y));
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 5   

  251   1          OLED_WrCmd(((x & 0xf0) >> 4) | 0x10);
  252   1          OLED_WrCmd((x & 0x0f));
  253   1      }
  254          
  255          //========================================================================
  256          // å‡½æ•°: void OLED_Frames()
  257          // æè¿°: OLEDåˆ·æ–°ç‡åˆ‡æ¢ç¨‹åº
  258          // å‚æ•°:
  259          // è¿”å›:
  260          // ç‰ˆæœ¬: V1.0, 2024-02-29
  261          //========================================================================
  262          void OLED_Frames()
  263          {
  264   1          if (dat00[0] & 0x0100)
  265   1          {
  266   2              if ((dat00[0] & 0x0080) && (dat00[0x0036]))
  267   2              {
  268   3                  if ((dat00[0x0007] != 0x0003))
  269   3                  {
  270   4                      OLED_WrCmd(0xd5);
  271   4                      OLED_WrCmd((u8)(((dat00[0x0057] << 4) & 0x00F0) + 1));
  272   4                      dat00[0x0007] = 3;
  273   4                  }
  274   3              }
  275   2              else if ((dat00[0x10] >= 0 && dat00[0x10] < 16 && dat00[0x1A] == 0) && (dat00[0x10] != 0x0005))
  276   2              {
  277   3                  if ((dat00[0x0006] & 0x0002) && (dat00[0x0007] != 0x0000)) // UIåŠ¨æ€ï¼Œä¸æ˜¯0x80
  278   3                  {
  279   4                      OLED_WrCmd(0xd5);
  280   4                      OLED_WrCmd((u8)((dat00[0x0054] << 4) & 0x00F0));
  281   4                      dat00[0x0007] = 0;
  282   4                  }
  283   3                  else if (((dat00[0x0006] & 0x0002) == 0) && (dat00[0x0007] != 0x0001)) // UIé™æ€ï¼Œä¸æ˜¯0x
             -50
  284   3                  {
  285   4                      OLED_WrCmd(0xd5);
  286   4                      OLED_WrCmd((u8)((dat00[0x0055] << 4) & 0x00F0));
  287   4                      dat00[0x0007] = 1;
  288   4                  }
  289   3              }
  290   2              else if ((dat00[0x0010] >= 0x0020) && (dat00[0x0010] <= 0x0022))
  291   2              {
  292   3                  if ((dat00[0x0006] & 0x0002) && (dat00[0x0007] != 0x0002) && (dat00[0x0010] == 0x0020)) // UI
             -åŠ¨æ€ï¼Œä¸æ˜¯0x80
  293   3                  {
  294   4                      OLED_WrCmd(0xd5);
  295   4                      if (OLED_InverseDisplay && dat00[0x0021])
  296   4                      {
  297   5                          OLED_WrCmd((u8)((dat00[0x0055] << 4) & 0x00F0));
  298   5                      }
  299   4                      else
  300   4                      {
  301   5                          OLED_WrCmd((u8)((dat00[0x0056] << 4) & 0x00F0));
  302   5                      }
  303   4      
  304   4                      dat00[0x0007] = 2;
  305   4                  }
  306   3                  else if (((dat00[0x0006] & 0x0002) == 0) && (dat00[0x0007] != 0x0003)) // UIé™æ€ï¼Œä¸æ˜¯0x
             -F1
  307   3                  {
  308   4                      OLED_WrCmd(0xd5);
  309   4                      if (OLED_InverseDisplay && dat00[0x0021])
  310   4                      {
  311   5                          OLED_WrCmd((u8)((dat00[0x0055] << 4) & 0x00F0));
  312   5                      }
  313   4                      else
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 6   

  314   4                      {
  315   5                          OLED_WrCmd((u8)(((dat00[0x0057] << 4) & 0x00F0) + 1));
  316   5                      }
  317   4      
  318   4                      dat00[0x0007] = 3;
  319   4                  }
  320   3              }
  321   2              else if ((dat00[0x10] == 0x0005) && (dat00[0x0007] != 0x0001))
  322   2              {
  323   3                  OLED_WrCmd(0xd5);
  324   3                  OLED_WrCmd((u8)((dat00[0x0055] << 4) & 0x00F0));
  325   3                  dat00[0x0007] = 1;
  326   3              }
  327   2      
  328   2              dat00[0] &= ~0x0100;
  329   2              // debug_8x8(dat00[0x0007],80,7);
  330   2          }
  331   1          // debug_8x8(dat00[0x0007],80,7);
  332   1      }
  333          
  334          //========================================================================
  335          // å‡½æ•°: OLED_InverseDisplay2()
  336          // æè¿°: å½“çƒ§å±ä¿æŠ¤æ‰“å¼€ï¼Œæ¯å¤©00:00~06:00åè‰² åƒåœ¾åŠŸèƒ½ï¼Œå¼Ÿä¸­å¼Ÿ
  337          // å‚æ•°:
  338          // è¿”å›: æ— ï¼ˆOLED_InverseDisplay  1åè‰²  0æ­£å¸¸ï¼‰
  339          // ç‰ˆæœ¬: V1.0 2024.02.08
  340          //========================================================================
  341          void OLED_InverseDisplay2()
  342          {
  343   1          if (dat00[0x26])
  344   1          {
  345   2              if (((Time_New[2] >= 0x00) && (Time_New[2] < 0x06)) && (dat00[0x0021] > 0) && (OLED_InverseDispla
             -y == 0))
  346   2              {
  347   3                  OLED_WrCmd(0xa7);
  348   3                  OLED_InverseDisplay = 1;
  349   3              }
  350   2              else if ((Time_New[2] >= 0x06) && (dat00[0x0021] > 0) && (OLED_InverseDisplay))
  351   2              {
  352   3                  OLED_WrCmd(0xa6);
  353   3                  OLED_InverseDisplay = 0;
  354   3              }
  355   2          }
  356   1      }
  357          
  358          //========================================================================
  359          // å‡½æ•°: void OLED_Init(void)
  360          // æè¿°: OLEDåˆå§‹åŒ–ç¨‹åº
  361          // å‚æ•°:
  362          // è¿”å›:
  363          // ç‰ˆæœ¬: V1.0, 2024-02-29
  364          //========================================================================
  365          void OLED_Init(void)
  366          {
  367   1          RST = 1;
  368   1          EA = 0;
  369   1          // delay_ms(50);
  370   1          Sleep_delay_Time(100);
  371   1          RST = 0;
  372   1          // delay_ms(50);
  373   1          Sleep_delay_Time(100);
  374   1          RST = 1;
  375   1          // delay_ms(50);
  376   1          Sleep_delay_Time(80);
  377   1          EA = 1;
  378   1          OLED_WrCmd(0xae);       //--turn off oled panel å…³é—­oledé¢æ¿
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 7   

  379   1          OLED_WrCmd(0x00);       //---set low column address  è®¾ç½®ä½åˆ—åœ°å€
  380   1          OLED_WrCmd(0x10);       //---set high column address    è®¾ç½®é«˜åˆ—åœ°å€
  381   1          OLED_WrCmd(0x40);       //--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)    
             -è®¾ç½®èµ·å§‹è¡Œåœ°å€è®¾ç½®æ˜ å°„RAMæ˜¾ç¤ºèµ·å§‹è¡Œï¼ˆ0x00?0x3Fï¼‰
  382   1          OLED_WrCmd(0x81);       //--set contrast controlregister   è®¾ç½®å¯¹æ¯”åº¦æ§åˆ¶å¯„å­˜å™¨
  383   1          OLED_WrCmd(Brightness); // Set SEG Output Current Brightness  è®¾ç½®SEGè¾“å‡ºç”µæµäº®åº¦
  384   1          OLED_WrCmd(0xa0);       //--Set SEG/Column Mapping     0xa0å·¦å³åç½® 0xa1æ­£å¸¸
  385   1          OLED_WrCmd(0xc0);       // Set COM/Row Scan Direction   0xc0ä¸Šä¸‹åç½® 0xc8æ­£å¸¸
  386   1          OLED_WrCmd(0xa6);       //--set normal display      è®¾ç½®æ­£å¸¸æ˜¾ç¤º
  387   1          OLED_WrCmd(0xa8);       //--set multiplex ratio(1 to 64)g   è®¾ç½®å¤ç”¨æ¯”ï¼ˆ1åˆ°64ï¼‰g
  388   1          OLED_WrCmd(0x3f);       //--1/64 duty
  389   1          OLED_WrCmd(0xd3);       //-set display offset Shift Mapping RAM Counter (0x00~0x3F) è®¾ç½®æ˜¾ç¤ºåç§
             -»é‡ç§»ä½æ˜ å°„RAMè®¡æ•°å™¨ï¼ˆ0x00?0x3Fï¼‰
  390   1          OLED_WrCmd(0x00);       //-not offset    ä¸æŠµæ¶ˆ
  391   1          OLED_WrCmd(0xd5);       //--set display clock divide ratio/oscillator frequency è®¾ç½®æ˜¾ç¤ºæ—¶é’Ÿåˆ†
             -é¢‘æ¯”/æŒ¯è¡å™¨é¢‘ç‡
  392   1          OLED_WrCmd(0x80);       //--set divide ratio, Set Clock as 100 Frames/Sec   è®¾ç½®åˆ†é¢‘æ¯”ï¼Œå°†æ—¶é
             -’Ÿè®¾ç½®ä¸º100å¸§/ç§’   TVæ¨¡å¼ä½¿ç”¨0x10æˆ–0xF1 å…¶ä»–ç”¨0x80 æŒ‡å—é’ˆ0x50
  393   1          dat00[0x0007] = 0;
  394   1          OLED_WrCmd(0xd9); //--set pre-charge period      è®¾å®šé¢„å……ç”µæ—¶é—´
  395   1          OLED_WrCmd(0xf1); // Set Pre-Charge as 15 Clocks & Discharge as 1 Clock å°†é¢„å……ç”µè®¾ç½®ä¸º15ä¸ªæ—¶
             -é’Ÿå¹¶å°†æ”¾ç”µè®¾ç½®ä¸º1ä¸ªæ—¶é’Ÿ
  396   1          OLED_WrCmd(0xda); //--set com pins hardware configuration è®¾ç½®comå¼•è„šçš„ç¡¬ä»¶é…ç½®
  397   1          OLED_WrCmd(0x12);
  398   1          OLED_WrCmd(0xdb); //--set vcomh
  399   1          OLED_WrCmd(0x40); // Set VCOM Deselect Level
  400   1          OLED_WrCmd(0x20); //-Set Page Addressing Mode (0x00/0x01/0x02)  è®¾ç½®é¡µé¢å¯»å€æ¨¡å¼
  401   1          OLED_WrCmd(0x02); //
  402   1          OLED_WrCmd(0x8d); //--set Charge Pump enable   è®¾ç½®ç”µè·æ³µå¯ç”¨/ç¦ç”¨
  403   1          OLED_WrCmd(0x10); //--set(0x10)å¯ç”¨ (0x14)ç¦ç”¨
  404   1          OLED_WrCmd(0xa4); // Disable Entire Display On (0xa4/0xa5)ç¦ç”¨æ•´ä¸ªæ˜¾ç¤ºæ‰“å¼€
  405   1          OLED_WrCmd(0xa6); // Disable Inverse Display On (0xa6/a7)ç¦ç”¨åå‘æ˜¾ç¤ºæ‰“å¼€********
  406   1          OLED_WrCmd(0xaf); //--turn on oled panel
  407   1          OLED_InverseDisplay2();
  408   1          OLED_Fill(0x00); // åˆå§‹æ¸…å±
  409   1          OLED_Set_Pos(0, 0);
  410   1      }
  411          
  412          //========================================================================
  413          // å‡½æ•°: void ZF_8X8(u8 x,u8 y,u8 ee)
  414          // æè¿°: æ˜¾ç¤º8*8å¤§å°çš„å­—ç¬¦ï¼Œæ•°æ®æ¥æºï¼šF8x8
  415          // å‚æ•°:  xï¼šxåæ ‡ y:yåæ ‡ ee:ç¬¬å‡ ä¸ªå­—ç¬¦
  416          // è¿”å›:
  417          // ç‰ˆæœ¬: V1.0 2023.02.05
  418          //========================================================================
  419          void ZF_8X8(u8 x, u8 y, u8 ee) //
  420          {
  421   1          u8 i;
  422   1          u8 *SPI_dat;
  423   1          if (SPI_DMA_USE)
  424   1          {
  425   2              SPI_dat = SPI_DmaTxBuffer2;
  426   2          }
  427   1          else
  428   1          {
  429   2              SPI_dat = SPI_DmaTxBuffer;
  430   2          }
  431   1          for (i = 0; i < 8; i++)
  432   1          {
  433   2              SPI_dat[i] = F8x8[ee][i];
  434   2          }
  435   1          OLED_Set_Pos(x, y);
  436   1          SPI_DMA_switch();
  437   1          SPI_DMA_TX(7);
  438   1      }
  439          
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 8   

  440          //========================================================================
  441          // å‡½æ•°: ZF_8X16(u8 x,u8 y,u8 ee)
  442          // æè¿°: æ˜¾ç¤º8*16å¤§å°çš„å­—ç¬¦ï¼Œæ•°æ®æ¥æºï¼šF8x16
  443          // å‚æ•°:  xï¼šxåæ ‡ y:yåæ ‡ ee:ç¬¬å‡ ä¸ªå­—ç¬¦
  444          // è¿”å›:
  445          // ç‰ˆæœ¬: V1.0 2023.02.05
  446          //========================================================================
  447          void ZF_8X16(u8 x, u8 y, u8 ee) //
  448          {
  449   1          u8 i;
  450   1          u8 k = 0;
  451   1          u8 *SPI_dat;
  452   1          if (SPI_DMA_USE)
  453   1          {
  454   2              SPI_dat = SPI_DmaTxBuffer2;
  455   2          }
  456   1          else
  457   1          {
  458   2              SPI_dat = SPI_DmaTxBuffer;
  459   2          }
  460   1          for (i = 0; i < 8; i++)
  461   1          {
  462   2              SPI_dat[i] = F8x16[ee][i];
  463   2          }
  464   1          OLED_Set_Pos(x, y);
  465   1          SPI_DMA_switch();
  466   1          SPI_DMA_TX(7);
  467   1      
  468   1          if (SPI_DMA_USE)
  469   1          {
  470   2              SPI_dat = SPI_DmaTxBuffer2;
  471   2          }
  472   1          else
  473   1          {
  474   2              SPI_dat = SPI_DmaTxBuffer;
  475   2          }
  476   1          for (; i < 16; i++)
  477   1          {
  478   2              SPI_dat[k] = F8x16[ee][i];
  479   2              k++;
  480   2          }
  481   1          OLED_Set_Pos(x, (u8)(y + 1));
  482   1          SPI_DMA_switch();
  483   1          SPI_DMA_TX(7);
  484   1      }
  485          //========================================================================
  486          // å‡½æ•°: void debug_8x8(int k,u8 x,u8 y)
  487          // æè¿°: ç”¨æ¥åœ¨å±å¹•ä¸Šæ‰“å°æ•°æ®ï¼Œ
  488          // å‚æ•°:  xï¼šxåæ ‡ y:yåæ ‡ k:éœ€è¦æ‰“å°çš„æ•°æ®ï¼ˆåªèƒ½æ˜¾ç¤º4ä½ï¼‰
  489          // è¿”å›:
  490          // ç‰ˆæœ¬: V1.0 2023.02.05
  491          //========================================================================
  492          void debug_8x8(int k, u8 x, u8 y) //
  493          {
  494   1          u8 i;
  495   1          u8 x1 = x;
  496   1          OLED_Set_Pos(x, y);
  497   1          for (i = 0; i < 5; i++)
  498   1          {
  499   2              ZF_8X8(x1, y, 10);
  500   2              x1 = x1 + 8;
  501   2          }
  502   1          OLED_Set_Pos(x, y);
  503   1          if (k < 0)
  504   1          {
  505   2      
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 9   

  506   2              ZF_8X8(x, y, 24);
  507   2              k = k * (-1);
  508   2          }
  509   1          else
  510   1          {
  511   2              ZF_8X8(x, y, 10);
  512   2          }
  513   1          x = x + 8;
  514   1      
  515   1          ZF_8X8(x, y, (u8)(k / 1000));
  516   1          x = x + 8;
  517   1      
  518   1          ZF_8X8(x, y, (u8)((k % 1000) / 100));
  519   1          x = x + 8;
  520   1      
  521   1          ZF_8X8(x, y, (u8)((k % 100) / 10));
  522   1          x = x + 8;
  523   1          ZF_8X8(x, y, (u8)(k % 10));
  524   1      }
  525          
  526          //========================================================================
  527          // å‡½æ•°: void nian(u16 ee,u8 y)
  528          // æè¿°: æ˜¾ç¤º8*16å¤§å°å­—ç¬¦çš„å¹´ä»½
  529          // å‚æ•°:  y:yåæ ‡ ee:å¹´ä»½
  530          // è¿”å›:
  531          // ç‰ˆæœ¬: V1.0 2023.02.05
  532          //========================================================================
  533          void nian(u16 ee, u8 y)
  534          {
  535   1          ZF_8X16(0, y, (u8)(ee / 1000));
  536   1          ZF_8X16(8, y, (u8)((ee % 1000) / 100));
  537   1          ZF_8X16(16, y, (u8)((ee % 100) / 10));
  538   1          ZF_8X16(24, y, (u8)(ee % 10));
  539   1          ZF_8X16(32, y, 12); // æœ«å°¾å¸¦æ–œæ 
  540   1      }
  541          
  542          //========================================================================
  543          // å‡½æ•°: void yue_ri(u8 x,u8 ee,bit g)
  544          // æè¿°: æ˜¾ç¤º8*16å¤§å°å­—ç¬¦çš„æœˆä»½æˆ–è€…æ—¥
  545          // å‚æ•°: x:xåæ ‡ y:yåæ ‡ ee:æœˆ/æ—¥ g:æœ«å°¾æ˜¯å¦å¸¦æ–œæ 
  546          // è¿”å›:
  547          // ç‰ˆæœ¬: V1.0 2023.02.05
  548          //========================================================================
  549          void yue_ri(u8 x, u8 ee, bit g)
  550          {
  551   1          ZF_8X16(x, 0, (u8)((ee % 100) / 10));
  552   1          ZF_8X16((u8)(x + 8), 0, (u8)(ee % 10));
  553   1          if (g)
  554   1              ZF_8X16((u8)(x + 16), 0, 12);
  555   1      }
  556          
  557          //========================================================================
  558          // å‡½æ•°: shifen(unsigned char t,unsigned char y)
  559          // æè¿°: æ˜¾ç¤º16*32å¤§å°å­—ç¬¦çš„æ—¶/åˆ†/ç§’
  560          // å‚æ•°: t:éœ€è¦æ˜¾ç¤ºçš„æ•°å­—/å­—ç¬¦ y:xåæ ‡
  561          // è¿”å›:
  562          // ç‰ˆæœ¬: V1.0  2023.02.05
  563          //========================================================================
  564          void shifen(unsigned char t, unsigned char y) //
  565          {
  566   1          unsigned char i;
  567   1          unsigned char j;
  568   1          unsigned char k;
  569   1          for (k = y; k < y + 16; k = k + 16)
  570   1          {
  571   2              for (j = 4; j < 8; j++)
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 10  

  572   2              {
  573   3                  OLED_Set_Pos(k, (u8)(j - 1));
  574   3                  for (i = 0; i < 16; i++)
  575   3                  {
  576   4                      OLED_WrDat(F8x16d[t * 4 + j - 4][i]);
  577   4                  }
  578   3              }
  579   2          }
  580   1      }
  581          
  582          //========================================================================
  583          // å‡½æ•°: shifen_2(unsigned char t,unsigned char y)
  584          // æè¿°: æ˜¾ç¤º16*32å¤§å°å­—ç¬¦çš„æ—¶/åˆ†/ç§’ï¼ˆç©ºå¿ƒï¼‰
  585          // å‚æ•°: t:éœ€è¦æ˜¾ç¤ºçš„æ•°å­—/å­—ç¬¦ y:xåæ ‡
  586          // è¿”å›:
  587          // ç‰ˆæœ¬: V1.0  2023.02.05
  588          //========================================================================
  589          void shifen_2(unsigned char t, unsigned char y)
  590          {
  591   1          unsigned char i;
  592   1          unsigned char j;
  593   1          unsigned char k;
  594   1          for (k = y; k < y + 16; k = k + 16)
  595   1          {
  596   2              for (j = 4; j < 8; j++)
  597   2              {
  598   3                  OLED_Set_Pos(k, (u8)(j - 2));
  599   3                  for (i = 0; i < 16; i++)
  600   3                  {
  601   4                      OLED_WrDat(F16x32_hollow[t * 4 + j - 4][i]);
  602   4                  }
  603   3              }
  604   2          }
  605   1      }
  606          
  607          //========================================================================
  608          // å‡½æ•°: OLED_16X16(u8 x,u8 y,u8 adde)
  609          // æè¿°: æ˜¾ç¤º16*16å¤§å°å­—ç¬¦çš„æ±‰å­—æˆ–è€…å…¶ä»–å­—ç¬¦æ˜¾ç¤ºï¼Œç”¨äºä¸»èœå•æ˜¾ç¤ºæ±‰å­—
  610          // å‚æ•°: x:xåæ ‡ y:yåæ ‡ adde:ç¬¬å‡ ä¸ªå­—ç¬¦
  611          // è¿”å›:
  612          // ç‰ˆæœ¬: V1.0  2023.02.05
  613          //========================================================================
  614          void OLED_16X16(u8 x, u8 y, u8 adde)
  615          {
  616   1          unsigned char i = 0;
  617   1          unsigned char j = 0;
  618   1          u8 *SPI_dat;
  619   1          adde = adde << 1;
  620   1          for (j = 0; j < 2; j++)
  621   1          {
  622   2              if (SPI_DMA_USE)
  623   2              {
  624   3                  SPI_dat = SPI_DmaTxBuffer2;
  625   3              }
  626   2              else
  627   2              {
  628   3                  SPI_dat = SPI_DmaTxBuffer;
  629   3              }
  630   2              for (i = 0; i < 16; i++)
  631   2              {
  632   3                  SPI_dat[i] = F16x16cd[adde][i];
  633   3              }
  634   2              OLED_Set_Pos(x, y);
  635   2              SPI_DMA_switch();
  636   2              SPI_DMA_TX(15);
  637   2              adde++;
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 11  

  638   2              y++;
  639   2          }
  640   1      }
  641          
  642          //========================================================================
  643          // å‡½æ•°: void OLED_8X8X3_MOV(u8 x,u8 y,u16 adde,u8 devia1,u8 devia2)
  644          // æè¿°: æŒ‡å—é’ˆæ ‡å°ºæ‰€ç”¨ï¼Œæ˜¾ç¤º3ä½è§’åº¦åœ¨æ ‡å°ºä¸Š
  645          // å‚æ•°: å¿˜äº†å•¥æ„æ€äº†ï¼Œ  devia1ï¼šä»ç¬¬åˆ—å¼€å§‹ç”»  devia2ï¼šç”»åˆ°ç¬¬å‡ ä¸ª
  646          // è¿”å›:
  647          // ç‰ˆæœ¬: V1.0  2023.02.05
  648          //========================================================================
  649          void OLED_8X8X3_MOV(u8 x, u8 y, u16 adde, u8 devia1, u8 devia2)
  650          {
  651   1          unsigned char i = 0;
  652   1          unsigned char j = 0;
  653   1          if (devia1 > 24)
  654   1              devia1 = 0;
  655   1          if (devia2 > 24)
  656   1              devia2 = 24;
  657   1          if (x >= 244)
  658   1          {
  659   2              devia1 = 256 - x;
  660   2              x = 0;
  661   2          }
  662   1          if (x < 128 && devia1 < 24 && devia2 <= 24)
  663   1          {
  664   2              for (i = 0; i < 24; i++)
  665   2              {
  666   3                  UI_TX[0][i] = 0x00;
  667   3              }
  668   2      
  669   2              if (adde < 10)
  670   2              {
  671   3                  for (i = 0; i < 8; i++)
  672   3                  {
  673   4                      UI_TX[0][8 + i] = F8x8[(adde % 10)][i];
  674   4                  }
  675   3              }
  676   2              else if (adde < 100)
  677   2              {
  678   3                  for (i = 0; i < 8; i++)
  679   3                  {
  680   4                      UI_TX[0][4 + i] = F8x8[((adde % 100) / 10)][i];
  681   4                  }
  682   3                  for (i = 0; i < 8; i++)
  683   3                  {
  684   4                      UI_TX[0][12 + i] = F8x8[(adde % 10)][i];
  685   4                  }
  686   3              }
  687   2              else if (adde < 1000)
  688   2              {
  689   3                  for (i = 0; i < 8; i++)
  690   3                  {
  691   4                      UI_TX[0][i] = F8x8[(adde / 100)][i];
  692   4                  }
  693   3                  for (i = 0; i < 8; i++)
  694   3                  {
  695   4                      UI_TX[0][8 + i] = F8x8[((adde % 100) / 10)][i];
  696   4                  }
  697   3                  for (i = 0; i < 8; i++)
  698   3                  {
  699   4                      UI_TX[0][16 + i] = F8x8[(adde % 10)][i];
  700   4                  }
  701   3              }
  702   2              OLED_Set_Pos(x, y);
  703   2              for (i = devia1; i < devia2; i++)
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 12  

  704   2              {
  705   3                  OLED_WrDat(UI_TX[0][i]);
  706   3              }
  707   2          }
  708   1      }
  709          
  710          //========================================================================
  711          // å‡½æ•°: void OLED_16X16_MOV(u8 x,u8 y,u8 adde,u8 devia1,u8 devia2)
  712          // æè¿°: æŒ‡å—é’ˆæ ‡å°ºæ‰€ç”¨ï¼Œæ˜¾ç¤ºä¸œå—è¥¿åŒ—æ±‰å­—åœ¨æ ‡å°ºä¸Š
  713          // å‚æ•°: ä¹Ÿå¿˜äº†å•¥æ„æ€äº†ï¼Œå’Œ8X8X3_MOVä¸€æ · devia1ï¼šä»ç¬¬åˆ—å¼€å§‹ç”»  devia2ï¼šç”»åˆ°ç¬¬å‡ ä
             -¸ª
  714          // è¿”å›:
  715          // ç‰ˆæœ¬: V1.0  2023.02.05
  716          //========================================================================
  717          void OLED_16X16_MOV(u8 x, u8 y, u8 adde, u8 devia1, u8 devia2)
  718          {
  719   1          unsigned char i = 0;
  720   1          unsigned char j = 0;
  721   1      
  722   1          if (devia1 > 16)
  723   1              devia1 = 0;
  724   1          if (devia2 > 16)
  725   1              devia2 = 16;
  726   1          if (x >= 248)
  727   1          {
  728   2              devia1 = 256 - x;
  729   2              x = 0;
  730   2          }
  731   1      
  732   1          if (x < 128 && devia1 < 16 && devia2 <= 16)
  733   1          {
  734   2              adde = adde << 1;
  735   2              for (j = 0; j < 2; j++)
  736   2              {
  737   3                  OLED_Set_Pos(x, y);
  738   3                  for (i = devia1; i < devia2; i++)
  739   3                  {
  740   4                      OLED_WrDat(F16x16_position[adde][i]);
  741   4                  }
  742   3                  adde++;
  743   3                  y++;
  744   3              }
  745   2          }
  746   1      }
  747          
  748          //========================================================================
  749          // å‡½æ•°: void OLED_32X32(u8 x,u8 y,u8 addr,u8 devia1,u8 devia2)
  750          // æè¿°: ä¸»èœå•å›¾æ ‡æ˜¾ç¤º
  751          // å‚æ•°: xï¼šxåæ ‡  yï¼šyåæ ‡  addrï¼šå›¾æ ‡æŒ‡å‘ devia1ï¼šä»ç¬¬åˆ—å¼€å§‹ç”»  devia2ï¼šç”»åˆ°ç¬¬å
             -‡ ä¸ª
  752          // è¿”å›:
  753          // ç‰ˆæœ¬: V1.0  2023.02.05
  754          //========================================================================
  755          void OLED_32X32(u8 x, u8 y, u8 addr, u8 devia1, u8 devia2)
  756          {
  757   1          u8 i = 0;
  758   1          u8 j = 0;
  759   1          u8 k = 0;
  760   1          u8 *SPI_dat;
  761   1          if (x < 128 && devia1 < 32 && devia2 <= 32)
  762   1          {
  763   2              addr = addr << 2;
  764   2              for (j = 0; j < 4; j++)
  765   2              {
  766   3      
  767   3                  k = 0;
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 13  

  768   3                  if (SPI_DMA_USE)
  769   3                  {
  770   4                      SPI_dat = SPI_DmaTxBuffer2;
  771   4                  }
  772   3                  else
  773   3                  {
  774   4                      SPI_dat = SPI_DmaTxBuffer;
  775   4                  }
  776   3                  for (i = devia1; i < devia2; i++)
  777   3                  {
  778   4                      SPI_dat[k] = F32x32[addr][i];
  779   4                      k++;
  780   4                  }
  781   3                  OLED_Set_Pos(x, y);
  782   3                  SPI_DMA_switch();
  783   3                  SPI_DMA_TX((u8)(k - 1));
  784   3                  addr++;
  785   3                  y++;
  786   3              }
  787   2          }
  788   1      }
  789          
  790          //========================================================================
  791          // å‡½æ•°: void OLED_ED()
  792          // æè¿°: å…³é—­OLEDæ˜¾ç¤º
  793          // å‚æ•°:
  794          // è¿”å›:
  795          // ç‰ˆæœ¬: V1.0  2023.02.05
  796          //========================================================================
  797          void OLED_ED()
  798          {
  799   1          OLED_WrCmd(0xae); //--turn off oled panel å…³é—­oledé¢æ¿
  800   1      }
  801          
  802          //========================================================================
  803          // å‡½æ•°: void OLED_GD()
  804          // æè¿°: ä¸»èœå•æ»šåŠ¨ï¼Œå¥½åƒæ²¡ç”¨ä¸Š
  805          // å‚æ•°:
  806          // è¿”å›:
  807          // ç‰ˆæœ¬: V1.0  2023.02.05
  808          //========================================================================
  809          void OLED_GD()
  810          {
  811   1          unsigned char i;
  812   1          unsigned char j = 0;
  813   1          unsigned char k = 48;
  814   1          unsigned char y = 0;
  815   1          unsigned char t = 0;
  816   1      
  817   1          for (j = 0; j < 4; j++)
  818   1          {
  819   2              OLED_Set_Pos(k, j);
  820   2              for (i = 0; i < 32; i++)
  821   2              {
  822   3                  OLED_WrDat(F32x32[j][i]);
  823   3              }
  824   2          }
  825   1          k = 96;
  826   1          for (j = 0; j < 4; j++)
  827   1          {
  828   2              OLED_Set_Pos(k, j);
  829   2              for (i = 0; i < 32; i++)
  830   2              {
  831   3                  OLED_WrDat(F32x32[j + 4][i]);
  832   3              }
  833   2          }
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 14  

  834   1          k = 0;
  835   1          for (j = 0; j < 4; j++)
  836   1          {
  837   2              OLED_Set_Pos(k, j);
  838   2              for (i = 0; i < 32; i++)
  839   2              {
  840   3                  OLED_WrDat(F32x32[j + 36][i]);
  841   3              }
  842   2          }
  843   1      }
  844          
  845          //========================================================================
  846          // å‡½æ•°: void OLED_3Figures(u16 num,u8 x,u8 y)
  847          // æè¿°: æŒ‡å—é’ˆæ˜¾ç¤ºè§’åº¦æ•°å€¼ï¼Œè‡ªåŠ¨å±…ä¸­ï¼ˆå¥½åƒæœ‰ç‚¹é—®é¢˜ï¼Œä½ ä»¬è‡ªå·±ä¿®ä¸€ä¸‹ç¬‘æ­»ï
             -¼‰
  848          // å‚æ•°:
  849          // è¿”å›:
  850          // ç‰ˆæœ¬: V1.0  2023.02.05
  851          //========================================================================
  852          
  853          void OLED_3Figures(u16 num, u8 x, u8 y)
  854          {
  855   1          u8 a = 0;
  856   1          u8 b = 0;
  857   1          u8 c = 0;
  858   1          u8 i = 0;
  859   1          u8 p = 0;
  860   1      
  861   1          a = (u8)((num % 1000) / 100);
  862   1          b = (u8)((num % 100) / 10);
  863   1          c = (u8)(num % 10);
  864   1          p = numlongGet(num);
  865   1      
  866   1          if (p <= 2)
  867   1          {
  868   2              ZF_8X16(x, y, 10);
  869   2              ZF_8X16((u8)(x + 16), y, 10);
  870   2          }
  871   1      
  872   1          if (p == 3)
  873   1          {
  874   2              ZF_8X16(x, y, a);
  875   2          }
  876   1          if (p >= 2)
  877   1          {
  878   2              x = x + 8;
  879   2              if (p == 2)
  880   2                  x = x + 4;
  881   2              ZF_8X16(x, y, b);
  882   2          }
  883   1          if (p >= 1)
  884   1          {
  885   2              x = x + 8;
  886   2              if (p == 1)
  887   2                  x = x + 12;
  888   2              ZF_8X16(x, y, c);
  889   2          }
  890   1      }
  891          
  892          //========================================================================
  893          // å‡½æ•°: void OLED_Progress_Bar(u16 num,u16 jx)
  894          // æè¿°: ä¸‰çº§èœå•è¿›åº¦æ¡
  895          // å‚æ•°: numï¼šå½“å‰å€¼  jxï¼šæœ€å¤§å€¼
  896          // è¿”å›:
  897          // ç‰ˆæœ¬: V1.0  2023.02.05
  898          //========================================================================
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 15  

  899          void OLED_Progress_Bar(u16 num, u16 jx)
  900          {
  901   1          u8 i;
  902   1          u8 j;
  903   1          u8 k;
  904   1          if (num <= jx)
  905   1          {
  906   2              j = ((u16)num * 60) / jx;
  907   2              OLED_Set_Pos(18, 5);
  908   2              OLED_WrDat(0xff);
  909   2      
  910   2              for (i = 0; i < j; i++)
  911   2              {
  912   3                  OLED_WrDat(0xff);
  913   3              }
  914   2              k = 60 - j;
  915   2              for (i = 0; i < k; i++)
  916   2              {
  917   3                  OLED_WrDat(0x81);
  918   3              }
  919   2      
  920   2              OLED_WrDat(0xff);
  921   2              k = (u8)((num % 1000) / 100);
  922   2              if (k != 0)
  923   2              {
  924   3                  ZF_8X8(82, 5, k);
  925   3              }
  926   2              else
  927   2              {
  928   3                  ZF_8X8(82, 5, 0x0A);
  929   3              }
  930   2      
  931   2              j = (u8)((num % 100) / 10);
  932   2              if (k == 0 && j == 0)
  933   2              {
  934   3                  ZF_8X8(90, 5, 0x0A);
  935   3              }
  936   2              else
  937   2              {
  938   3                  ZF_8X8(90, 5, j);
  939   3              }
  940   2              ZF_8X8(98, 5, (u8)(num % 10));
  941   2          }
  942   1      }
  943          
  944          //========================================================================
  945          // å‡½æ•°:void OLED_Region_Fill()
  946          // æè¿°: ç»˜åˆ¶ä¸€ä¸ªå¸¦è¾¹çš„çª—å£ï¼Œç”¨äºä¸‰çº§èœå•
  947          // å‚æ•°:
  948          // è¿”å›:
  949          // ç‰ˆæœ¬: V1.0  2023.02.05
  950          //========================================================================
  951          void OLED_Region_Fill()
  952          {
  953   1          u8 k;
  954   1          u8 q;
  955   1          u8 i;
  956   1          for (k = 0; k < 6; k++)
  957   1          {
  958   2              OLED_Set_Pos(16, (u8)(1 + k));
  959   2              for (i = 0; i < 96; i++)
  960   2              {
  961   3                  if (k == 0)
  962   3                  {
  963   4                      q = 0x01;
  964   4                  }
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 16  

  965   3                  else if (k == 5)
  966   3                  {
  967   4                      q = 0x80;
  968   4                  }
  969   3                  else
  970   3                  {
  971   4                      q = 0;
  972   4                  }
  973   3                  if ((i == 0) | (i == (95)))
  974   3                  {
  975   4                      q = 0xff;
  976   4                  }
  977   3                  OLED_WrDat(q);
  978   3              }
  979   2          }
  980   1      }
  981          
  982          //**********************************************************************
  983          //
  984          //    ç¬¬äºŒèœå•åŠŸèƒ½åŒº
  985          //
  986          //**********************************************************************
  987          
  988          //========================================================================
  989          // å‡½æ•°:void OLED_FZQP(u8 x,u8 y)
  990          // æè¿°: æ¸…ç©ºä¸€ä¸ªåŒºåŸŸï¼ˆäºŒçº§èœå•æ»šåŠ¨ç»“æŸåå¯èƒ½å¦‚æœå›¾æ¡ˆå®šæ ¼çš„è¯ä¼šæœ‰æ®‹ç•™ï¼‰
  991          // å‚æ•°:
  992          // è¿”å›:
  993          // ç‰ˆæœ¬: V1.0  2023.02.05
  994          //========================================================================
  995          void OLED_FZQP(u8 x, u8 y)
  996          {
  997   1          u8 i = 0;
  998   1          OLED_Set_Pos(x, y);
  999   1          for (i = 0; i < 64; i++)
 1000   1          {
 1001   2              OLED_WrDat(0x00);
 1002   2          }
 1003   1      }
 1004          
 1005          //========================================================================
 1006          // å‡½æ•°: void OLED_16_16V(u8 (*dat)[16],u16 adde,u8 x,u8 y,bit p)
 1007          // æè¿°: (*dat)[16]ï¼šç‚¹é˜µ  addeï¼šäºŒç»´æ•°ç»„ç¬¬å‡ è¡Œ x:xåæ ‡ y:yåæ ‡ p ï¼šæ˜¯å¦åè‰²ï¼Œç”¨ä
             -ºåšå…‰æ ‡
 1008          // å‚æ•°:
 1009          // è¿”å›:
 1010          // ç‰ˆæœ¬: V1.0  2023.02.05
 1011          //========================================================================
 1012          void OLED_16_16V(u8 (*dat)[16], u16 adde, u8 x, u8 y, bit p)
 1013          {
 1014   1          u8 i = 0;
 1015   1          u8 j = 0;
 1016   1          u8 k = 0;
 1017   1          u8 *SPI_dat;
 1018   1          j = adde;
 1019   1          adde = adde + 8;
 1020   1      
 1021   1          k = 0;
 1022   1          if (SPI_DMA_USE)
 1023   1          {
 1024   2              SPI_dat = SPI_DmaTxBuffer2;
 1025   2          }
 1026   1          else
 1027   1          {
 1028   2              SPI_dat = SPI_DmaTxBuffer;
 1029   2          }
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 17  

 1030   1          for (; j < adde; j = j + 2)
 1031   1          {
 1032   2              for (i = 0; i < 16; i++)
 1033   2              {
 1034   3                  if (p)
 1035   3                  {
 1036   4                      SPI_dat[k] = dat[j][i];
 1037   4                  }
 1038   3                  else
 1039   3                  {
 1040   4                      SPI_dat[k] = ~dat[j][i];
 1041   4                  }
 1042   3                  k++;
 1043   3              }
 1044   2          }
 1045   1          OLED_Set_Pos(x, y);
 1046   1          SPI_DMA_switch();
 1047   1          SPI_DMA_TX((u8)(k - 1));
 1048   1      }
 1049          
 1050          //========================================================================
 1051          // å‡½æ•°: void OLED_16_16Vabc(u8 (*dat)[16],u16 adde,u8 x,u8 y,u8 c,bit jj,u8 Number)
 1052          // æè¿°: æ˜¾ç¤ºåŠè¡Œï¼ˆå·¦å³ï¼‰äºŒçº§èœå•
 1053          // å‚æ•°: (*dat)[16]ï¼šç‚¹é˜µ  addeï¼šäºŒç»´æ•°ç»„ç¬¬å‡ è¡Œ x:xåæ ‡ y:yåæ ‡ c:å¿˜äº†ï¼Œå¥½åƒæ˜¯0å°±
             -ä¸å‘ä¸Šèµ°é¡¶å‡ºå±å¹•ï¼Œç”¨åœ¨ç¬¬ä¸€ä¸ªé€‰é¡¹  jjï¼šå¿˜äº† Numberï¼šæˆ‘ä¹Ÿå¿˜äº†ä¸ºä»€ä¹ˆä¸€å®šè¦å†™8äº†
 1054          //                                                                                                       
             -    ä½ ä»¬å¯ä»¥å†™ä¸åŒçš„å€¼è¯•è¯•æ•ˆæœ
 1055          // è¿”å›:
 1056          // ç‰ˆæœ¬: V1.0  2023.02.05
 1057          //========================================================================
 1058          void OLED_16_16Vabc(u8 (*dat)[16], u16 adde, u8 x, u8 y, u8 c, bit jj, u8 Number)
 1059          {
 1060   1          u8 i = 0;
 1061   1          u8 j = 0;
 1062   1          u16 t = 0;
 1063   1      
 1064   1          y = (u8)(y / 8);
 1065   1          j = adde;
 1066   1          adde = adde + Number;
 1067   1          if (jj)
 1068   1              c = c % 8;
 1069   1          if (y < 8)
 1070   1          {
 1071   2              OLED_Set_Pos(x, y);
 1072   2              for (; j < adde; j = j + 2)
 1073   2              {
 1074   3                  for (i = 0; i < 16; i++)
 1075   3                  {
 1076   4                      if (!jj)
 1077   4                      {
 1078   5                          t = dat[j + 1][i] * 256 + dat[j][i];
 1079   5                          OLED_WrDat((u8)(t >> c));
 1080   5                      }
 1081   4                      else
 1082   4                      {
 1083   5                          t = dat[j][i];
 1084   5                          OLED_WrDat((u8)(t << c));
 1085   5                      }
 1086   4                  }
 1087   3              }
 1088   2          }
 1089   1          y = (u8)(y + 1);
 1090   1          j = adde - (Number - 1);
 1091   1          adde = adde + 1;
 1092   1          if (y < 8)
 1093   1          {
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 18  

 1094   2              OLED_Set_Pos(x, y);
 1095   2              for (; j < adde; j = j + 2)
 1096   2              {
 1097   3                  for (i = 0; i < 16; i++)
 1098   3                  {
 1099   4                      if (!jj)
 1100   4                      {
 1101   5                          t = dat[j][i];
 1102   5                          OLED_WrDat((u8)(t >> c));
 1103   5                      }
 1104   4                      else
 1105   4                      {
 1106   5                          t = dat[j][i] * 256 + dat[j - 1][i];
 1107   5                          OLED_WrDat((u8)(t >> (8 - c)));
 1108   5                      }
 1109   4                  }
 1110   3              }
 1111   2          }
 1112   1          y = (u8)(y + 1);
 1113   1          j = adde - Number;
 1114   1          if (y < 8)
 1115   1          {
 1116   2              OLED_Set_Pos(x, y);
 1117   2              for (; j < adde; j = j + 2)
 1118   2              {
 1119   3                  for (i = 0; i < 16; i++)
 1120   3                  {
 1121   4                      if (!jj)
 1122   4                      {
 1123   5                      }
 1124   4                      else
 1125   4                      {
 1126   5                          t = dat[j][i];
 1127   5                          OLED_WrDat((u8)(t >> (8 - c)));
 1128   5                      }
 1129   4                  }
 1130   3              }
 1131   2          }
 1132   1      
 1133   1          // u8 i = 0;
 1134   1          //     u8 j = 0;
 1135   1          //     u16 t = 0;
 1136   1          //    u8 k=0;
 1137   1          //    u8 *SPI_dat;
 1138   1          //     y = (u8)(y/8);
 1139   1          //     j = adde;
 1140   1          //     adde = adde + Number;
 1141   1          //     if(jj) c = c % 8;
 1142   1          //     if(y < 8)
 1143   1          //     {
 1144   1          //        k=0;
 1145   1          //        if(SPI_DMA_USE)
 1146   1          //        {
 1147   1          //            SPI_dat = SPI_DmaTxBuffer2;
 1148   1          //        }
 1149   1          //        else
 1150   1          //        {
 1151   1          //            SPI_dat = SPI_DmaTxBuffer;
 1152   1          //        }
 1153   1          //         for(; j<adde; j = j + 2)
 1154   1          //         {
 1155   1          //             for(i=0; i<16; i++)
 1156   1          //             {
 1157   1          //                 if(!jj)
 1158   1          //                 {
 1159   1          //                     t = dat[j+1][i]*256+dat[j][i];
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 19  

 1160   1          //                     SPI_dat[k]=((u8)(t >> c));
 1161   1          //                 }
 1162   1          //                 else
 1163   1          //                 {
 1164   1          //                     t = dat[j][i];
 1165   1          //                     SPI_dat[k]=((u8)(t << c));
 1166   1          //                 }
 1167   1          //                k++;
 1168   1          //             }
 1169   1      
 1170   1          //        }
 1171   1          //        OLED_Set_Pos(x,y);
 1172   1          //        SPI_DMA_switch();
 1173   1          //        SPI_DMA_TX((u8)(k-1));
 1174   1          //
 1175   1          //
 1176   1          //
 1177   1          //    }
 1178   1          //    y = (u8)(y+1);
 1179   1          //    j = adde  - (Number - 1);
 1180   1          //    adde = adde + 1;
 1181   1          //    if(y < 8)
 1182   1          //    {
 1183   1          //        k=0;
 1184   1          //        if(SPI_DMA_USE)
 1185   1          //        {
 1186   1          //            SPI_dat = SPI_DmaTxBuffer2;
 1187   1          //        }
 1188   1          //        else
 1189   1          //        {
 1190   1          //            SPI_dat = SPI_DmaTxBuffer;
 1191   1          //        }
 1192   1          //        for(; j<adde; j = j + 2)
 1193   1          //        {
 1194   1          //            for(i=0; i<16; i++)
 1195   1          //            {
 1196   1          //                if(!jj)
 1197   1          //                {
 1198   1          //                    t = dat[j][i];
 1199   1          //                    SPI_dat[k]=((u8)(t >> c));
 1200   1          //                }
 1201   1          //                else
 1202   1          //                {
 1203   1          //                    t = dat[j][i]*256+dat[j-1][i];
 1204   1          //                    SPI_dat[k]=((u8)(t >> (8 - c)));
 1205   1          //                }
 1206   1          //                k++;
 1207   1          //            }
 1208   1          //
 1209   1          //        }
 1210   1          //        OLED_Set_Pos(x,y);
 1211   1          //        SPI_DMA_switch();
 1212   1          //        SPI_DMA_TX((u8)(k-1));
 1213   1          //    }
 1214   1          //    y = (u8)(y+1);
 1215   1          //    j = adde  - Number;
 1216   1          //    if(y < 8)
 1217   1          //    {
 1218   1          //        k=0;
 1219   1          //        if(SPI_DMA_USE)
 1220   1          //        {
 1221   1          //            SPI_dat = SPI_DmaTxBuffer2;
 1222   1          //        }
 1223   1          //        else
 1224   1          //        {
 1225   1          //            SPI_dat = SPI_DmaTxBuffer;
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 20  

 1226   1          //        }
 1227   1          //        for(; j<adde; j = j + 2)
 1228   1          //        {
 1229   1          //            for(i=0; i<16; i++)
 1230   1          //            {
 1231   1          //                if(!jj)
 1232   1          //                {
 1233   1          //                      SPI_dat[k]=0x00;
 1234   1          //                }
 1235   1          //                else
 1236   1          //                {
 1237   1          //                    t = dat[j][i];
 1238   1          //                    SPI_dat[k]=((u8)(t >> (8 - c)));
 1239   1          //                }
 1240   1          //                k++;
 1241   1          //            }
 1242   1          //
 1243   1          //        }
 1244   1          //        OLED_Set_Pos(x,y);
 1245   1          //        SPI_DMA_switch();
 1246   1          //        SPI_DMA_TX((u8)(k-1));
 1247   1      
 1248   1          //    }
 1249   1      }
 1250          
 1251          //========================================================================
 1252          // å‡½æ•°: u8** TVR(u8 i)
 1253          // æè¿°: æ˜¾ç¤ºæ•°ç»„æ˜ å°„å‡½æ•°ï¼Œç”¨äºç›´æ¥ç”¨å…‰æ ‡ç›´æ¥æŒ‡ç¤ºå¯¹åº”çš„ç‚¹é˜µ
 1254          // å‚æ•°:  iï¼šå…‰æ ‡çš„å€¼
 1255          // è¿”å›:  **pp éœ€è¦æ˜¾ç¤ºçš„ç‚¹é˜µ
 1256          // ç‰ˆæœ¬: V1.0  2023.02.05
 1257          //========================================================================
 1258          u8 **TVR(u8 i)
 1259          {
 1260   1          u8 **pp;
 1261   1      
 1262   1          switch (i)
 1263   1          {
 1264   2          case 0x0000:
 1265   2              pp = TVMode_16; // æ ‡å‡†æ¨¡å¼
 1266   2              break;
 1267   2          case 0x0001:
 1268   2              pp = SleepMode_16; // æ ‡å‡†æ¨¡å¼
 1269   2              break;
 1270   2          case 0x0002:
 1271   2              pp = Environment; // ç¯å¢ƒå‚æ•°
 1272   2              break;
 1273   2          case 0x0003:
 1274   2              pp = Brightness_setting; // äº®åº¦è®¾ç½®
 1275   2              break;
 1276   2          case 0x0004:
 1277   2              pp = CompassMenu_16; // æŒ‡å—é’ˆ
 1278   2              break;
 1279   2      
 1280   2          case 0x0006:
 1281   2              pp = time_set; // æ—¶é—´è®¾ç½®
 1282   2              break;
 1283   2      
 1284   2          case 0x000A:
 1285   2              pp = Sound_setting; // å£°éŸ³è®¾ç½®
 1286   2              break;
 1287   2          case 0x000C:
 1288   2              pp = Power_Options; // ç”µæºç®¡ç†
 1289   2              break;
 1290   2          case 0x000E:
 1291   2              pp = System_Information; // ç³»ç»Ÿä¿¡æ¯
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 21  

 1292   2              break;
 1293   2      
 1294   2          case 0x0040:
 1295   2              pp = System_Information_data; // ç³»ç»Ÿä¿¡æ¯æ•°æ®
 1296   2              break;
 1297   2      
 1298   2          case 0x0060:
 1299   2              pp = UI_dat; // ç³»ç»Ÿä¿¡æ¯æ•°æ®
 1300   2              break;
 1301   2      
 1302   2          case 0x0080:
 1303   2              pp = F8x16d;
 1304   2              break;
 1305   2      
 1306   2          default:
 1307   2              pp = TVMode_16;
 1308   2              break;
 1309   2          }
 1310   1          return pp;
 1311   1      }
 1312          
 1313          //========================================================================
 1314          // å‡½æ•°: void OLED_16_16V2(u8 (*dat)[16],u16 adde,u8 x,u8 y,bit p)
 1315          // æè¿°: æ²¡ç”¨åˆ°ï¼Œå¥½åƒä¹‹å‰æ˜¯äºŒçº§èœå•æ˜¾ç¤ºçš„ï¼Œåæ¥ä¸ºäº†èƒ½è‡ªå®šä¹‰å›¾æ¡ˆå°±æ¢äº†ä¸ªæ
             -–¹æ³•å®ç°
 1316          // å‚æ•°:
 1317          // è¿”å›:
 1318          // ç‰ˆæœ¬: V1.0  2023.02.05
 1319          //========================================================================
 1320          
 1321          void OLED_16_16V2(u8 (*dat)[16], u16 adde, u8 x, u8 y, bit p)
 1322          {
 1323   1      
 1324   1          OLED_16_16V(dat, adde, x, y, p);
 1325   1          adde = adde + 1;
 1326   1          OLED_16_16V(dat, adde, x, (u8)(y + 1), p);
 1327   1          OLED_FZQP(0, 5);
 1328   1      }
 1329          
 1330          //========================================================================
 1331          // å‡½æ•°: void OLED_Mean2_fill(u8 p,u8 a)
 1332          // æè¿°: UI_datæ•°ç»„é‡Œé¢å…¨éƒ¨å¡«å……ä¸€ä¸ªæ•°ï¼Œå¹³æ—¶ç”¨æ¥æ¸…ç©º
 1333          // å‚æ•°:
 1334          // è¿”å›:
 1335          // ç‰ˆæœ¬: V1.0  2023.02.05
 1336          //========================================================================
 1337          
 1338          void OLED_Mean2_fill(u8 p, u8 a)
 1339          {
 1340   1          u8 i;
 1341   1          u8 j;
 1342   1          if (p <= 8)
 1343   1          {
 1344   2              for (j = 0; j < p; j++)
 1345   2              {
 1346   3                  for (i = 0; i < 16; i++)
 1347   3                  {
 1348   4                      UI_dat[j][i] = a;
 1349   4                  }
 1350   3              }
 1351   2          }
 1352   1      }
 1353          
 1354          //========================================================================
 1355          // å‡½æ•°: void OLED_Mean2_fill2(u8 a)
 1356          // æè¿°: UI_datæ•°ç»„é‡Œé¢å…¨éƒ¨å¡«å……ä¸€ä¸ªå¼€å…³å›¾å½¢ï¼Œ
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 22  

 1357          // å‚æ•°: aï¼šæ‰“å¼€è¿˜æ˜¯å…³é—­
 1358          // è¿”å›:
 1359          // ç‰ˆæœ¬: V1.0  2023.02.05
 1360          //========================================================================
 1361          void OLED_Mean2_fill2(u8 a)
 1362          {
 1363   1          u8 i;
 1364   1          u8 j;
 1365   1          u8(*pa)[16];
 1366   1      
 1367   1          if (a > 0)
 1368   1          {
 1369   2              pa = KG_K;
 1370   2          }
 1371   1          else
 1372   1          {
 1373   2              pa = KG_G;
 1374   2          }
 1375   1          for (j = 0; j < 4; j++)
 1376   1          {
 1377   2              for (i = 0; i < 16; i++)
 1378   2              {
 1379   3                  UI_dat[j + 4][i] = pa[j][i];
 1380   3              }
 1381   2          }
 1382   1          OLED_Mean2_fill(4, 0);
 1383   1      }
 1384          
 1385          //========================================================================
 1386          // å‡½æ•°: void ZQ8x8(u8 a,u8 dat)
 1387          // æè¿°: UI_datæ•°ç»„é‡Œé¢å…¨éƒ¨å¡«å……ä¸€ä¸ª8*8æ•°å­—ï¼Œ
 1388          // å‚æ•°:
 1389          // è¿”å›:
 1390          // ç‰ˆæœ¬: V1.0  2023.02.05
 1391          //========================================================================
 1392          void ZQ8x8(u8 a, u8 dat)
 1393          {
 1394   1          u8 i = 0;
 1395   1          u8 p = 0;
 1396   1          u8 b = 0;
 1397   1          p = dat / 10;
 1398   1          for (i = 0; i < 8; i++)
 1399   1          {
 1400   2              UI_dat[a][i] = F8x8_2[p][i];
 1401   2          }
 1402   1          p = dat % 10;
 1403   1          for (; i < 16; i++)
 1404   1          {
 1405   2              UI_dat[a][i] = F8x8_2[p][b];
 1406   2              b++;
 1407   2          }
 1408   1      }
 1409          
 1410          //========================================================================
 1411          // å‡½æ•°: u8 numlongGet(u16 a)
 1412          // æè¿°: è·å–è¿™ä¸ªæ•°æ®æ˜¯å‡ ä½çš„æ•°æ®
 1413          // å‚æ•°:
 1414          // è¿”å›:
 1415          // ç‰ˆæœ¬: V1.0  2023.02.05
 1416          //========================================================================
 1417          u8 numlongGet(u16 a)
 1418          {
 1419   1          if (a >= 10000)
 1420   1          {
 1421   2              a = 5;
 1422   2          }
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 23  

 1423   1          else if (a >= 1000)
 1424   1          {
 1425   2              a = 4;
 1426   2          }
 1427   1          else if (a >= 100)
 1428   1          {
 1429   2              a = 3;
 1430   2          }
 1431   1          else if (a >= 10)
 1432   1          {
 1433   2              a = 2;
 1434   2          }
 1435   1          else
 1436   1          {
 1437   2              a = 1;
 1438   2          }
 1439   1          return a;
 1440   1      }
 1441          
 1442          //========================================================================
 1443          // å‡½æ•°: OLED_Mean2_fill_num(u8 a,u8 b,u8 (*dat)[16])
 1444          // æè¿°: å¿˜äº†ï¼Œæ€»ä¹‹æ˜¯å¡«å……ä¸€ä¸ª8*16çš„æ•°å­—åˆ°æ•°ç»„é‡Œé¢ï¼Œä¾›OLED_Mean2_fill_num2è£…æ•°æ®ç
             -š„
 1445          // å‚æ•°:
 1446          // è¿”å›:
 1447          // ç‰ˆæœ¬: V1.0  2023.02.05
 1448          //========================================================================
 1449          void OLED_Mean2_fill_num(u8 a, u8 b, u8 (*dat)[16])
 1450          {
 1451   1          u8 i;
 1452   1          u8 j;
 1453   1          u8 c = 0;
 1454   1          j = (a >> 1) << 1;
 1455   1          c = (a % 2) << 3;
 1456   1      
 1457   1          for (i = 0; i < 8; i++)
 1458   1          {
 1459   2              UI_dat[j][i + c] = dat[b][i];
 1460   2          }
 1461   1          j = j + 1;
 1462   1          for (i = 0; i < 8; i++)
 1463   1          {
 1464   2              UI_dat[j][i + c] = dat[b][i + 8];
 1465   2          }
 1466   1      }
 1467          
 1468          //========================================================================
 1469          // å‡½æ•°: void OLED_Mean2_fill_num2(u16 a)
 1470          // æè¿°: å¡«å……äºŒçº§èœå•å­—ç¬¦ï¼Œæ ¹æ®dat00_maxæŸ¥è¯¢åˆ°çš„ç±»å‹è‡ªåŠ¨å¡«å……å¼€å…³ã€æ•°å­—ã€å•ä
             -½ã€å°æ•°ç‚¹ç­‰
 1471          // å‚æ•°:
 1472          // è¿”å›:
 1473          // ç‰ˆæœ¬: V1.0  2023.02.05
 1474          //========================================================================
 1475          void OLED_Mean2_fill_num2(u16 a)
 1476          {
 1477   1          u8 i = 0;
 1478   1          u8 k;
 1479   1          u16 dat = 0;
 1480   1          u8 xsd = 0;
 1481   1          u8 fh = 0;
 1482   1          u8 adde = 7;
 1483   1          dat = dat00[a];
 1484   1          xsd = (u8)(dat00_max[a] >> 14);
 1485   1          fh = (u8)((dat00_max[a] >> 12) & 0x0003);
 1486   1          k = (u8)((dat00_max[a] >> 8) & 0x000F);
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 24  

 1487   1          OLED_Mean2_fill(8, 0);
 1488   1          if (fh > 0)
 1489   1          {
 1490   2              for (i = 0; i < fh; i++)
 1491   2              {
 1492   3                  OLED_Mean2_fill_num(adde, (u8)(k - i), F8x16_unit);
 1493   3                  adde--;
 1494   3              }
 1495   2          }
 1496   1          k = numlongGet(dat);
 1497   1          if (xsd)
 1498   1          {
 1499   2              if (k <= xsd)
 1500   2              {
 1501   3                  k = xsd + 2;
 1502   3              }
 1503   2              else
 1504   2              {
 1505   3                  k = k + 1;
 1506   3              }
 1507   2          }
 1508   1          for (i = 0; i < k; i++)
 1509   1          {
 1510   2              if (i == xsd && xsd != 0)
 1511   2              {
 1512   3                  OLED_Mean2_fill_num(adde, 0x0B, F8x16);
 1513   3                  adde--;
 1514   3              }
 1515   2              else
 1516   2              {
 1517   3                  OLED_Mean2_fill_num(adde, (u8)(dat % 10), F8x16);
 1518   3                  if (adde > 0)
 1519   3                      adde--;
 1520   3                  dat = dat / 10;
 1521   3              }
 1522   2          }
 1523   1      }
 1524          
 1525          //========================================================================
 1526          // å‡½æ•°: void shifen_dh_z(u8 t,u8 x,u8 yy,u16 y,u8  limit)
 1527          // æè¿°: æ˜¾ç¤ºæ»šåŠ¨çš„æ—¶åˆ†ç§’----å…¶ä¸­ä¸€è¡Œ
 1528          // å‚æ•°: t:æ¯ä¸ªå­—ç¬¦çš„ç¬¬å‡ è¡Œï¼ˆ4è¡Œä¸€ä¸ªå®Œæ•´å­—ç¬¦ï¼‰  x:xåæ ‡   yy:yåæ ‡    y:åç§»  li
             -mit:æœ€å¤§å€¼ï¼Œæ¯”å¦‚æ—¶çš„åä½ï¼Œæœ€å¤§å€¼å°±æ˜¯2ï¼Œè¶…è¿‡2è·³å›0
 1529          // è¿”å›:
 1530          // ç‰ˆæœ¬: V1.0 2023.02.05
 1531          //========================================================================
 1532          void shifen_dh_z(u8 t, u8 x, u8 yy, u16 y, u8 limit) //
 1533          {
 1534   1          //    u8 i;
 1535   1          //    OLED_Set_Pos(x,yy);
 1536   1          //    for(i=0; i<16; i++)
 1537   1          //    {
 1538   1          //        OLED_WrDat((F8x16d[(t+y/8) %  limit][i] >> (y % 8)) | (F8x16d[(t+1+y/8) %  limit][i] << 8-(
             -y % 8)));
 1539   1          //    }
 1540   1          u8 i;
 1541   1          u8 *SPI_dat;
 1542   1          if (SPI_DMA_USE)
 1543   1          {
 1544   2              SPI_dat = SPI_DmaTxBuffer2;
 1545   2          }
 1546   1          else
 1547   1          {
 1548   2              SPI_dat = SPI_DmaTxBuffer;
 1549   2          }
 1550   1          for (i = 0; i < 16; i++)
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 25  

 1551   1          {
 1552   2              SPI_dat[i] = (F8x16d[(t + y / 8) % limit][i] >> (y % 8)) | (F8x16d[(t + 1 + y / 8) % limit][i] <<
             - 8 - (y % 8));
 1553   2          }
 1554   1          OLED_Set_Pos(x, yy);
 1555   1          SPI_DMA_switch();
 1556   1          SPI_DMA_TX((u8)(i - 1));
 1557   1      }
 1558          
 1559          //========================================================================
 1560          // å‡½æ•°: void shifen_dh(u8 x,u8 yy,u16 y,u8  limit)
 1561          // æè¿°: æ˜¾ç¤ºæ»šåŠ¨çš„æ—¶åˆ†ç§’
 1562          // å‚æ•°: x:xåæ ‡   yy:    y:yåæ ‡ limit:å¼ºåˆ¶æ˜¾ç¤ºï¼Œç”¨äºåˆå§‹åŒ–
 1563          // è¿”å›:
 1564          // ç‰ˆæœ¬: V1.0 2023.02.05
 1565          //========================================================================
 1566          void shifen_dh(u8 x, u8 yy, u16 y, u8 limit)
 1567          {
 1568   1          unsigned char i;
 1569   1          for (i = 0; i < 4; i++)
 1570   1          {
 1571   2              shifen_dh_z(i, x, (u8)(yy + i), y, limit);
 1572   2          }
 1573   1      }
 1574          
 1575          //========================================================================
 1576          // å‡½æ•°: void IU_Battery_Icon_S_1(u8 x,u8 y)
 1577          // æè¿°: TVæ¨¡å¼ç”µæ± ç•Œé¢æ˜¾ç¤º---å¤§ç”µæ± ä¸‹é¢ç”µé‡çš„æ˜¾ç¤º
 1578          // å‚æ•°: x:xåæ ‡ y:yåæ ‡
 1579          // è¿”å›:
 1580          // ç‰ˆæœ¬: V1.0 2023.02.05
 1581          //========================================================================
 1582          void IU_Battery_Icon_S_1(u8 x, u8 y)
 1583          {
 1584   1          u8 j, k;
 1585   1      
 1586   1          k = (u8)(dat00[0x00E5] / 1000);
 1587   1          if (k != 0)
 1588   1          {
 1589   2              ZF_8X8((u8)(x + 24), y, k);
 1590   2          }
 1591   1          else
 1592   1          {
 1593   2              ZF_8X8((u8)(x + 24), y, 0x0A);
 1594   2          }
 1595   1      
 1596   1          j = (u8)((dat00[0x00E5] % 1000) / 100);
 1597   1          if (k == 0 && j == 0)
 1598   1          {
 1599   2              ZF_8X8((u8)(x + 32), y, 0x0A);
 1600   2          }
 1601   1          else
 1602   1          {
 1603   2              ZF_8X8((u8)(x + 32), y, j);
 1604   2          }
 1605   1          ZF_8X8((u8)(x + 40), y, (u8)((dat00[0x00E5] % 100) / 10));
 1606   1      }
 1607          
 1608          //========================================================================
 1609          // å‡½æ•°: IU_Battery_Icon_S(u8 x,u8 y,u8 p)
 1610          // æè¿°: å³ä¸Šè§’ç”µæ± UIæ˜¾ç¤º
 1611          // å‚æ•°: x:xåæ ‡ y:yåæ ‡ p:å¼ºåˆ¶æ˜¾ç¤ºï¼Œç”¨äºåˆå§‹åŒ–
 1612          // è¿”å›:
 1613          // ç‰ˆæœ¬: V1.0 2023.02.05
 1614          //========================================================================
 1615          void IU_Battery_Icon_S(u8 x, u8 y, u8 p)
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 26  

 1616          {
 1617   1          u16 a = 0;
 1618   1          u8 j = 0;
 1619   1          u8 i;
 1620   1          u8 k = 0;
 1621   1      
 1622   1          if ((dat00[0x00E5] != Battery_PE_Low) || p)
 1623   1          {
 1624   2              a = dat00[0x00E5] / 83;
 1625   2              OLED_Set_Pos((u8)(x + 8), y);
 1626   2      
 1627   2              for (i = 0; i < 16; i++)
 1628   2              {
 1629   3                  if (i == 0)
 1630   3                  {
 1631   4                      OLED_WrDat(0xFf);
 1632   4                  }
 1633   3                  else if (i == 1)
 1634   3                  {
 1635   4                      OLED_WrDat(0x81);
 1636   4                  }
 1637   3                  else if (i <= 12)
 1638   3                  {
 1639   4                      if ((a + 1) >= i)
 1640   4                      {
 1641   5                          OLED_WrDat(0xBD);
 1642   5                      }
 1643   4                      else
 1644   4                      {
 1645   5                          OLED_WrDat(0x81);
 1646   5                      }
 1647   4                  }
 1648   3                  else if (i <= 13)
 1649   3                  {
 1650   4                      if (a == 12)
 1651   4                      {
 1652   5                          OLED_WrDat(0x99);
 1653   5                      }
 1654   4                      else
 1655   4                      {
 1656   5                          OLED_WrDat(0x81);
 1657   5                      }
 1658   4                  }
 1659   3                  else if (i <= 14)
 1660   3                  {
 1661   4                      OLED_WrDat(0xC3);
 1662   4                  }
 1663   3                  else if (i <= 15)
 1664   3                  {
 1665   4                      OLED_WrDat(0x3C);
 1666   4                  }
 1667   3              }
 1668   2      
 1669   2              IU_Battery_Icon_S_1(x, y);
 1670   2              if (dat00[0x00E1])
 1671   2              {
 1672   3                  ZF_8X8(x, y, 0x0B);
 1673   3              }
 1674   2              else
 1675   2              {
 1676   3                  ZF_8X8(x, y, 0x0A);
 1677   3              }
 1678   2              Battery_PE_Low = dat00[0x00E5];
 1679   2          }
 1680   1      }
 1681          
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 27  

 1682          //*************************ç”µæ± ç•Œé¢UI********************
 1683          
 1684          //========================================================================
 1685          // å‡½æ•°: void IU_Battery_cheek()
 1686          // æè¿°: TVæ¨¡å¼ç”µæ± ç•Œé¢æ˜¾ç¤º---ç”»å‡ºå¤§ç”µæ± å¤–å£³
 1687          // å‚æ•°:
 1688          // è¿”å›:
 1689          // ç‰ˆæœ¬: V1.0 2023.02.05
 1690          //========================================================================
 1691          void IU_Battery_cheek()
 1692          {
 1693   1          u8 i = 0;
 1694   1          for (i = 2; i < 6; i++)
 1695   1          {
 1696   2              ZF_8X8(120, i, 16);
 1697   2          }
 1698   1      
 1699   1          for (i = 2; i < 6; i++)
 1700   1          {
 1701   2              ZF_8X8(96, i, 16);
 1702   2          }
 1703   1      
 1704   1          OLED_Set_Pos(104, 1);
 1705   1          for (i = 0; i < 2; i++)
 1706   1          {
 1707   2              OLED_WrDat(0x3c);
 1708   2          }
 1709   1          for (i = 0; i < 12; i++)
 1710   1          {
 1711   2              OLED_WrDat(0x3f);
 1712   2          }
 1713   1          for (i = 0; i < 2; i++)
 1714   1          {
 1715   2              OLED_WrDat(0x3c);
 1716   2          }
 1717   1      
 1718   1          OLED_Set_Pos(104, 6);
 1719   1          for (i = 0; i < 16; i++)
 1720   1          {
 1721   2              OLED_WrDat(0x3c);
 1722   2          }
 1723   1          ZF_8X8(96, 1, 18);
 1724   1          ZF_8X8(120, 1, 19);
 1725   1          ZF_8X8(96, 6, 21);
 1726   1          ZF_8X8(120, 6, 20);
 1727   1      
 1728   1          ZF_8X16(80, 5, 25);
 1729   1          ZF_8X16(88, 5, 26);
 1730   1      
 1731   1          ZF_8X16(8, 5, 11);
 1732   1          ZF_8X16(28, 5, 27);
 1733   1      }
 1734          
 1735          //========================================================================
 1736          // å‡½æ•°: void IU_16x8_Fill(u8 x,u8 y,u8 t)
 1737          // æè¿°: x:xåæ ‡   y:yåæ ‡  tï¼šéœ€è¦å†™å…¥çš„æ•°æ®
 1738          // å‚æ•°:
 1739          // è¿”å›:
 1740          // ç‰ˆæœ¬: V1.0 2023.02.05
 1741          //========================================================================
 1742          void IU_16x8_Fill(u8 x, u8 y, u8 t)
 1743          {
 1744   1          u8 i;
 1745   1          OLED_Set_Pos(x, y);
 1746   1          for (i = 0; i < 16; i++)
 1747   1          {
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 28  

 1748   2              OLED_WrDat(t);
 1749   2          }
 1750   1      }
 1751          
 1752          //========================================================================
 1753          // å‡½æ•°: IU_Battery_cheek_renovate_count(u16 a,u8 x,u8 y,u8 t)
 1754          // æè¿°: TVæ¨¡å¼ç”µæ± ç•Œé¢æ˜¾ç¤º---ç”»å‡ºå¤§ç”µæ± é‡Œé¢çš„ä¸€å±‚çš„ç”µé‡
 1755          // å‚æ•°: aï¼šç”µé‡  x:xåæ ‡   y:yåæ ‡  tï¼šå±‚æ•°
 1756          // è¿”å›:
 1757          // ç‰ˆæœ¬: V1.0 2023.02.05
 1758          //========================================================================
 1759          void IU_Battery_cheek_renovate_count(u16 a, u8 x, u8 y, u8 t)
 1760          {
 1761   1          u8 b, p;
 1762   1          p = t + 8;
 1763   1          if (a >= p)
 1764   1          {
 1765   2              b = 0xff;
 1766   2          }
 1767   1          else if (a > t && a <= p)
 1768   1          {
 1769   2              b = 0xff;
 1770   2              b = b << (p - a);
 1771   2          }
 1772   1          else
 1773   1          {
 1774   2              b = 0;
 1775   2          }
 1776   1          IU_16x8_Fill(x, y, b);
 1777   1      }
 1778          
 1779          //========================================================================
 1780          // å‡½æ•°: IU_Battery_cheek_renovate()
 1781          // æè¿°: TVæ¨¡å¼ç”µæ± ç•Œé¢æ˜¾ç¤º---å…¶ä»–éƒ¨åˆ†çš„åˆ·æ–°
 1782          // å‚æ•°:
 1783          // è¿”å›:
 1784          // ç‰ˆæœ¬: V1.0 2023.02.05
 1785          //========================================================================
 1786          void IU_Battery_cheek_renovate()
 1787          {
 1788   1          u16 a = 0;
 1789   1          u8 b = 0;
 1790   1          u8 i;
 1791   1          a = (u8)((u32)dat00[0x00E5] * 100 / 3125);
 1792   1      
 1793   1          // miao((u8)dat00[0x00E2]);
 1794   1      
 1795   1          if (dat00[0x00E2])
 1796   1          {
 1797   2              IU_Battery_cheek_renovate_count(a, 104, 2, 24);
 1798   2              IU_Battery_cheek_renovate_count(a, 104, 3, 16);
 1799   2              IU_Battery_cheek_renovate_count(a, 104, 4, 8);
 1800   2              IU_Battery_cheek_renovate_count(a, 104, 5, 0);
 1801   2          }
 1802   1          else
 1803   1          {
 1804   2              IU_16x8_Fill(104, 2, 0);
 1805   2              IU_16x8_Fill(104, 5, 0);
 1806   2              OLED_Set_Pos(104, 3);
 1807   2              ZF_8X8(104, 3, 22);
 1808   2              ZF_8X8(112, 3, 23);
 1809   2              ZF_8X8(104, 4, 23);
 1810   2              ZF_8X8(112, 4, 22);
 1811   2          }
 1812   1      
 1813   1          if (dat00[0x00E1])
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 29  

 1814   1          {
 1815   2      
 1816   2              if ((u8)(Time_New[0] % 6) == 0)
 1817   2              {
 1818   3                  ZF_8X16(72, 3, 10);
 1819   3                  ZF_8X16(80, 3, 10);
 1820   3              }
 1821   2              ZF_8X16((u8)(24 + (Time_New[0] % 6) * 8), 3, 10);
 1822   2              ZF_8X16((u8)(32 + (Time_New[0] % 6) * 8), 3, 23);
 1823   2              ZF_8X16((u8)(40 + (Time_New[0] % 6) * 8), 3, 24);
 1824   2          }
 1825   1          else
 1826   1          {
 1827   2              if (dat00_low[0x00E1] != dat00[0x00E1])
 1828   2              {
 1829   3                  OLED_Set_Pos(24, 3);
 1830   3                  for (i = 0; i < 56; i++)
 1831   3                  {
 1832   4                      OLED_WrDat(0x00);
 1833   4                  }
 1834   3                  OLED_Set_Pos(24, 4);
 1835   3                  for (i = 0; i < 56; i++)
 1836   3                  {
 1837   4                      OLED_WrDat(0x00);
 1838   4                  }
 1839   3              }
 1840   2          }
 1841   1      
 1842   1          if (dat00[0x00E4] >= 100)
 1843   1          {
 1844   2              ZF_8X16(54, 5, (u8)((dat00[0x00E4] % 1000) / 100));
 1845   2          }
 1846   1          else
 1847   1          {
 1848   2              ZF_8X16(54, 5, 10);
 1849   2          }
 1850   1      
 1851   1          if (dat00[0x00E4] >= 10)
 1852   1          {
 1853   2              ZF_8X16(62, 5, (u8)((dat00[0x00E4] % 100) / 10));
 1854   2          }
 1855   1          else
 1856   1          {
 1857   2              ZF_8X16(62, 5, 10);
 1858   2          }
 1859   1          ZF_8X16(70, 5, (u8)(dat00[0x00E4] % 10));
 1860   1      
 1861   1          ZF_8X16(0, 5, (u8)((dat00[0x00E3] / 1000)));
 1862   1          ZF_8X16(12, 5, (u8)((dat00[0x00E3] % 1000) / 100));
 1863   1          ZF_8X16(20, 5, (u8)((dat00[0x00E3] % 100) / 10));
 1864   1      
 1865   1          IU_Battery_Icon_S_1(76, 7);
 1866   1      }
 1867          
 1868          void OLED_16_16V2a()
 1869          {
 1870   1          u8 i = 0;
 1871   1          delay_ms(200);
 1872   1          delay_ms(200);
 1873   1          ;
 1874   1          delay_ms(200);
 1875   1          delay_ms(200);
 1876   1          delay_ms(200);
 1877   1          delay_ms(200);
 1878   1          delay_ms(200);
 1879   1          delay_ms(200);
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  01:57:59  PAGE 30  

 1880   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =     23410     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       768     ------
  xdata-const size     =    ------     ------
  edata size           =         2         59
  bit size             =    ------          4
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        10     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
