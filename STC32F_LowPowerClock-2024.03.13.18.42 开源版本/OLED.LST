C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE OLED
OBJECT MODULE PLACED IN OLED.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE OLED.c XSMALL OPTIMIZE(9,SPEED) BROWSE DEBUG TABS(2) 

stmt  level    source

    1          #include "OLED.h"
    2          #include "time.h"
    3          #include "dianzhen.h"
    4          #include "SecondaryMenu.h"
    5          
    6          extern u16 dat00[System_data_num];
    7          extern u16 dat00_low[System_data_num];
    8          extern u8 xdata dat00_flag[System_data_num];
    9          extern u16 xdata dat00_max[System_data_num];
   10          
   11          extern u8  UI_dat[8][16];
   12          
   13          extern u8  UI_TX[3][64];
   14          
   15          extern u8 Time_New[7];
   16          
   17          extern u32 AlarmClock[16];
   18          
   19          extern u16 Battery_PE_Low;
   20          
   21          
   22          u8 xdata SPI_DmaTxBuffer[256]; //_at_ DMA_TX_ADDR;
   23          u8 xdata SPI_DmaTxBuffer2[256]; //_at_ DMA_TX_ADDR;
   24          u8 xdata SPI_DmaRxBuffer[256]; //_at_ DMA_RX_ADDR
   25          
   26          u8 SPI_DMA_USE = 0;
   27          
   28          
   29          u8 SPI_DMA_buy = 0;
   30          
   31          
   32          extern u8 OLED_InverseDisplay;
   33          extern u16 Sleep36;
   34          
   35          //========================================================================
   36          // å‡½æ•°: void SPI_init(void)
   37          // æè¿°: SPIåˆå§‹åŒ–ï¼ŒSTCå®˜æ–¹ä¾‹ç¨‹æ”¹çš„
   38          // å‚æ•°:                                                                                               
             -  
   39          // è¿”å›: 
   40          // ç‰ˆæœ¬: V1.0  2023.02.05
   41          //========================================================================
   42          void SPI_init(void)
   43          {
   44   1          P_SW2 = 0x80;
   45   1          SPCTL |=  (1 << 7);//å¿½ç•¥ SS å¼•è„šåŠŸèƒ½ï¼Œä½¿ç”¨ MSTR ç¡®å®šå™¨ä»¶æ˜¯ä¸»æœºè¿˜æ˜¯ä»æœº
   46   1          SPCTL |=  (1 << 6); //ä½¿èƒ½ SPI åŠŸèƒ½
   47   1          SPCTL &= ~(1 << 5); //å…ˆå‘é€/æ¥æ”¶æ•°æ®çš„é«˜ä½ï¼ˆ MSBï¼‰
   48   1          SPCTL |=  (1 << 4); //è®¾ç½®ä¸»æœºæ¨¡å¼
   49   1      
   50   1      //    SPCTL &= ~(1 << 3); //SCLK ç©ºé—²æ—¶ä¸ºä½ç”µå¹³ï¼ŒSCLK çš„å‰æ—¶é’Ÿæ²¿ä¸ºä¸Šå‡æ²¿ï¼Œåæ—¶é’Ÿæ²¿ä
             -¸ºä¸‹é™æ²¿
   51   1      //    SPCTL &= ~(1 << 2); //æ•°æ® SS ç®¡è„šä¸ºä½ç”µå¹³é©±åŠ¨ç¬¬ä¸€ä½æ•°æ®å¹¶åœ¨ SCLK çš„åæ—¶é’Ÿæ²¿æ
             -”¹å˜æ•°æ®
   52   1      
   53   1      //    SPCTL |= (1 << 3); //SCLK ç©ºé—²æ—¶ä¸ºä½ç”µå¹³ï¼ŒSCLK çš„å‰æ—¶é’Ÿæ²¿ä¸ºä¸Šå‡æ²¿ï¼Œåæ—¶é’Ÿæ²¿ä¸
             -ºä¸‹é™æ²¿
   54   1      //    SPCTL |= (1 << 2); //æ•°æ® SS ç®¡è„šä¸ºä½ç”µå¹³é©±åŠ¨ç¬¬ä¸€ä½æ•°æ®å¹¶åœ¨ SCLK çš„åæ—¶é’Ÿæ²¿æ”
             -¹å˜æ•°æ®
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 2   

   55   1          SPCTL |= 0x0c;
   56   1      
   57   1          //SPCTL = (SPCTL & ~3) | 0;   //SPI æ—¶é’Ÿé¢‘ç‡é€‰æ‹©, 0: 4T, 1: 8T,  2: 16T,  3: 2T
   58   1      
   59   1          SPCTL &= 0xFC;
   60   1          SPCTL |= 0x03;
   61   1      
   62   1          P_SW1 &= 0xf7;     //IOå£åˆ‡æ¢. 0: P1.2/P5.4 P1.3 P1.4 P1.5, 1: P2.2 P2.3 P2.4 P2.5, 2: P5.4 P4.0 P
             -4.1 P4.3, 3: P3.5 P3.4 P3.3 P3.2
   63   1          P_SW1 |= 0x04;
   64   1          //P_SW1 = (P_SW1 & ~(3<<1)) | (1<<1);  //IOå£åˆ‡æ¢. 0: P1.2/P5.4 P1.3 P1.4 P1.5, 1: P2.2 P2.3 P2.4 
             -P2.5, 2: P5.4 P4.0 P4.1 P4.3, 3: P3.5 P3.4 P3.3 P3.2
   65   1          SCK = 1;    // set clock to low initial state
   66   1          SI = 1;
   67   1          SPSTAT = 0x80 + 0x40;
   68   1          HSSPI_CFG2 |=0x20;
   69   1          SPI_DMA_buy = 0;
   70   1      
   71   1      }
   72          
   73          
   74          //========================================================================
   75          // å‡½æ•°: void DMA_Config(void)
   76          // æè¿°: SPI DMA åŠŸèƒ½é…ç½®.STCå®˜æ–¹ä¾‹ç¨‹
   77          // å‚æ•°: none.
   78          // è¿”å›: none.
   79          // ç‰ˆæœ¬: V1.0, 2021-5-6
   80          //========================================================================
   81          void SPI_DMA_Config(void)
   82          {
   83   1          DMA_SPI_STA = 0x00;
   84   1          DMA_SPI_CFG = 0xC0;   //bit7 1:Enable Interrupt
   85   1          DMA_SPI_AMTH = 0x00;
   86   1          DMA_SPI_AMT = 0xff;   //è®¾ç½®ä¼ è¾“æ€»å­—èŠ‚æ•°ï¼šn+1
   87   1      
   88   1          DMA_SPI_TXAH = (u8)((u16)&SPI_DmaTxBuffer >> 8);  //SPIå‘é€æ•°æ®å­˜å‚¨åœ°å€
   89   1          DMA_SPI_TXAL = (u8)((u16)&SPI_DmaTxBuffer);
   90   1          DMA_SPI_RXAH = (u8)((u16)&SPI_DmaRxBuffer >> 8);  //SPIæ¥æ”¶æ•°æ®å­˜å‚¨åœ°å€
   91   1          DMA_SPI_RXAL = (u8)((u16)&SPI_DmaRxBuffer);
   92   1      
   93   1          //DMA_SPI_CFG2 = 0x01;  //01:P2.2
   94   1          DMA_SPI_CR = 0x81;    //bit7 1:ä½¿èƒ½ SPI_DMA, bit6 1:å¼€å§‹ SPI_DMA ä¸»æœºæ¨¡å¼, bit0 1:æ¸…é™¤ SPI_DM
             -A FIFO
   95   1      }
   96          
   97          
   98          
   99          //========================================================================
  100          // å‡½æ•°: void SPI_DMA()
  101          // æè¿°: SPI å‘é€
  102          // å‚æ•°: 
  103          // è¿”å›: 
  104          // ç‰ˆæœ¬: V1.0, 2021-5-6
  105          //========================================================================
  106          void SPI_DMA()
  107          {
  108   1          if(DMA_SPI_STA)//DMA æ­£å¿™å°±è·³è¿‡
  109   1          {
  110   2              DMA_SPI_STA = 0;
  111   2              SPSTAT = 0x80 + 0x40;
  112   2              SPI_DMA_buy = 0;
  113   2          }
  114   1      
  115   1      }
  116          //========================================================================
  117          // å‡½æ•°: void SPI_DMA_delay()
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 3   

  118          // æè¿°: ç­‰å¾…SPI DMAå‘é€å®Œæˆï¼Œå¹¶è¿›å…¥IDLEæ¨¡å¼
  119          // å‚æ•°: 
  120          // è¿”å›: 
  121          // ç‰ˆæœ¬: V1.0, 2021-5-6
  122          //========================================================================
  123          void SPI_DMA_delay()
  124          {
  125   1      
  126   1          while(SPI_DMA_buy) //ç­‰DMAå‘å®Œ
  127   1          {
  128   2              _nop_();
  129   2              _nop_();
  130   2              _nop_();
  131   2              _nop_();
  132   2              PCON = IDL;                                 //MCUè¿›å…¥IDLEæ¨¡å¼
  133   2              _nop_();
  134   2              _nop_();
  135   2              _nop_();
  136   2              _nop_();
  137   2          }
  138   1      
  139   1      }
  140          //========================================================================
  141          // å‡½æ•°: void SPI_DMA_TX(u8 num)
  142          // æè¿°: SPI DMA å‘é€æ•°æ®ï¼ŒåŒæ—¶åˆ‡æ¢ç©ºé—²åŒºåŸŸæ ‡å¿—ä½
  143          // å‚æ•°: num ï¼š å‘é€num+1ä¸ªå­—èŠ‚
  144          // è¿”å›: 
  145          // ç‰ˆæœ¬: V1.0, 2021-5-6
  146          //========================================================================
  147          void SPI_DMA_TX(u8 num)
  148          {
  149   1      
  150   1          SPI_DMA_delay();
  151   1          SPI_DMA_buy = 1;
  152   1          DMA_SPI_AMT = num;
  153   1          if(SPI_DMA_USE)
  154   1          {
  155   2              SPI_DMA_USE=0;
  156   2          }
  157   1          else
  158   1          {
  159   2              SPI_DMA_USE=1;
  160   2          }
  161   1          DMA_SPI_CR |= 0x40;
  162   1      
  163   1      }
  164          
  165          
  166          
  167          //========================================================================
  168          // å‡½æ•°: void SPI_DMA_switch()
  169          // æè¿°: æ ¹æ®æ¢ç©ºé—²åŒºåŸŸæ ‡å¿—ä½åˆ‡æ¢è£…å¡«çš„DMAåœ°å€
  170          // å‚æ•°: 
  171          // è¿”å›: 
  172          // ç‰ˆæœ¬: V1.0, 2023-12-15
  173          //========================================================================
  174          void SPI_DMA_switch()
  175          {
  176   1      
  177   1          if(SPI_DMA_USE)
  178   1          {
  179   2              DMA_SPI_TXAH = (u8)((u16)&SPI_DmaTxBuffer2 >> 8); //SPIå‘é€æ•°æ®å­˜å‚¨åœ°å€
  180   2              DMA_SPI_TXAL = (u8)((u16)&SPI_DmaTxBuffer2);
  181   2          }
  182   1          else
  183   1          {
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 4   

  184   2              DMA_SPI_TXAH = (u8)((u16)&SPI_DmaTxBuffer >> 8);  //SPIå‘é€æ•°æ®å­˜å‚¨åœ°å€
  185   2              DMA_SPI_TXAL = (u8)((u16)&SPI_DmaTxBuffer);
  186   2          }
  187   1      
  188   1      }
  189          
  190          
  191          
  192          
  193          
  194          
  195          
  196          
  197          
  198          //========================================================================
  199          // å‡½æ•°: void LCD_Writ_Bus(u8 out)
  200          // æè¿°: SPIå†™ä¸€ä¸ªå­—èŠ‚
  201          // å‚æ•°: dat éœ€è¦å‘çš„æ•°æ®
  202          // è¿”å›: 
  203          // ç‰ˆæœ¬: V1.0, 2021-12-15
  204          //========================================================================
  205          void LCD_Writ_Bus(u8 out)
  206          {
  207   1          u16 i = 500;
  208   1          SPI_DMA_delay();
  209   1          SPDAT = out;
  210   1          while(((SPSTAT & 0xC0) == 0)); //æ¸…0 SPIFå’ŒWCOLæ ‡å¿—
  211   1          SPSTAT = 0xC0;
  212   1      }
  213          //========================================================================
  214          // å‡½æ•°: void OLED_WrDat(u8 dat)
  215          // æè¿°: SPIå†™ä¸€ä¸ªå­—èŠ‚
  216          // å‚æ•°: dat éœ€è¦å‘çš„æ•°æ®
  217          // è¿”å›: 
  218          // ç‰ˆæœ¬: V1.0, 2021-12-15
  219          //========================================================================
  220          void OLED_WrDat(u8 dat)
  221          {
  222   1          SPI_DMA_delay();
  223   1          LCD_Writ_Bus(dat);
  224   1      }
  225          
  226          
  227          //========================================================================
  228          // å‡½æ•°: void OLED_WrDat(u8 dat)
  229          // æè¿°: SPIå†™ä¸€ä¸ªå‘½ä»¤å­—èŠ‚
  230          // å‚æ•°: dat éœ€è¦å‘çš„æ•°æ®
  231          // è¿”å›: 
  232          // ç‰ˆæœ¬: V1.0, 2021-12-15
  233          //========================================================================
  234          void OLED_WrCmd(u8 dat1)
  235          {
  236   1          SPI_DMA_delay();
  237   1          DC=0;//å†™å‘½ä»¤
  238   1          LCD_Writ_Bus(dat1);
  239   1          DC=1;
  240   1      }
  241          
  242          //========================================================================
  243          // å‡½æ•°: void OLED_Fill(u8 bmp_dat)
  244          // æè¿°: OLEDæ•´å±å¡«å……
  245          // å‚æ•°: bmp_dat éœ€å¡«å……çš„æ•°æ®
  246          // è¿”å›: 
  247          // ç‰ˆæœ¬: V1.0, 2021-12-15
  248          //========================================================================
  249          void OLED_Fill(u8 bmp_dat)
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 5   

  250          {
  251   1          u8 y,x;
  252   1          for(y=0; y<8; y++)
  253   1          {
  254   2              OLED_WrCmd((u8)(0xb0+y));
  255   2              OLED_WrCmd(0x00);
  256   2              OLED_WrCmd(0x10);
  257   2              for(x=0; x<X_WIDTH; x++)
  258   2                  OLED_WrDat(bmp_dat);
  259   2          }
  260   1      }
  261          
  262          
  263          
  264          //========================================================================
  265          // å‡½æ•°: void OLED_Set_Pos(u8 x, u8 y)
  266          // æè¿°: è®¾ç½®OLEDå¡«å……æ•°æ®ä½ç½®,ä¸­æ™¯ä¾‹ç¨‹
  267          // å‚æ•°: x:Xåæ ‡  y:yåæ ‡  
  268          // è¿”å›: 
  269          // ç‰ˆæœ¬: V1.0, 2021-12-15
  270          //========================================================================
  271          void OLED_Set_Pos(u8 x, u8 y)
  272          {
  273   1          OLED_WrCmd((u8)(0xb0+y));
  274   1          OLED_WrCmd(((x & 0xf0)>>4)|0x10);
  275   1          OLED_WrCmd((x & 0x0f));
  276   1      }
  277          
  278          
  279          //========================================================================
  280          // å‡½æ•°: void OLED_Frames()
  281          // æè¿°: OLEDåˆ·æ–°ç‡åˆ‡æ¢ç¨‹åº
  282          // å‚æ•°: 
  283          // è¿”å›: 
  284          // ç‰ˆæœ¬: V1.0, 2024-02-29
  285          //========================================================================
  286          void OLED_Frames()
  287          {
  288   1          if(dat00[0] & 0x0100)
  289   1          {
  290   2              if((dat00[0] & 0x0080) && (dat00[0x0036]))
  291   2              {
  292   3                  if((dat00[0x0007] != 0x0003))
  293   3                  {
  294   4                      OLED_WrCmd(0xd5);
  295   4                      OLED_WrCmd((u8)(((dat00[0x0057]<<4) & 0x00F0)+1));
  296   4                      dat00[0x0007] = 3;
  297   4                  }
  298   3              }
  299   2              else if((dat00[0x10] >= 0 && dat00[0x10] < 16 && dat00[0x1A] == 0) && (dat00[0x10] != 0x0005))
  300   2              {
  301   3                  if((dat00[0x0006] & 0x0002) && (dat00[0x0007] != 0x0000))//UIåŠ¨æ€ï¼Œä¸æ˜¯0x80
  302   3                  {
  303   4                      OLED_WrCmd(0xd5);
  304   4                      OLED_WrCmd((u8)((dat00[0x0054]<<4) & 0x00F0));
  305   4                      dat00[0x0007] = 0;
  306   4                  }
  307   3                  else if(((dat00[0x0006] & 0x0002) == 0) && (dat00[0x0007] != 0x0001))//UIé™æ€ï¼Œä¸æ˜¯0x50
  308   3                  {
  309   4                      OLED_WrCmd(0xd5);
  310   4                      OLED_WrCmd((u8)((dat00[0x0055]<<4) & 0x00F0));
  311   4                      dat00[0x0007] = 1;
  312   4                  }
  313   3              }
  314   2              else if((dat00[0x0010] >= 0x0020) && (dat00[0x0010] <= 0x0022))
  315   2              {
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 6   

  316   3                  if((dat00[0x0006] & 0x0002) && (dat00[0x0007] != 0x0002)  && (dat00[0x0010] == 0x0020))//UIåŠ
             -¨æ€ï¼Œä¸æ˜¯0x80
  317   3                  {
  318   4                      OLED_WrCmd(0xd5);
  319   4                      if(OLED_InverseDisplay && dat00[0x0021])
  320   4                      {
  321   5                          OLED_WrCmd((u8)((dat00[0x0055]<<4) & 0x00F0));
  322   5                      }
  323   4                      else
  324   4                      {
  325   5                          OLED_WrCmd((u8)((dat00[0x0056]<<4) & 0x00F0));
  326   5                      }
  327   4      
  328   4                      dat00[0x0007] = 2;
  329   4                  }
  330   3                  else if(((dat00[0x0006] & 0x0002) == 0)  && (dat00[0x0007] != 0x0003)  )//UIé™æ€ï¼Œä¸æ˜¯0x
             -F1
  331   3                  {
  332   4                      OLED_WrCmd(0xd5);
  333   4                      if(OLED_InverseDisplay && dat00[0x0021])
  334   4                      {
  335   5                          OLED_WrCmd((u8)((dat00[0x0055]<<4) & 0x00F0));
  336   5                      }
  337   4                      else
  338   4                      {
  339   5                          OLED_WrCmd((u8)(((dat00[0x0057]<<4) & 0x00F0)+1));
  340   5                      }
  341   4      
  342   4                      dat00[0x0007] = 3;
  343   4      
  344   4                  }
  345   3              }
  346   2              else if((dat00[0x10] == 0x0005) && (dat00[0x0007] != 0x0001) )
  347   2              {
  348   3                  OLED_WrCmd(0xd5);
  349   3                  OLED_WrCmd((u8)((dat00[0x0055]<<4) & 0x00F0));
  350   3                  dat00[0x0007] = 1;
  351   3              }
  352   2      
  353   2              dat00[0] &= ~0x0100;
  354   2              //debug_8x8(dat00[0x0007],80,7);
  355   2          }
  356   1          // debug_8x8(dat00[0x0007],80,7);
  357   1      }
  358          
  359          
  360          
  361          //========================================================================
  362          // å‡½æ•°: OLED_InverseDisplay2()
  363          // æè¿°: å½“çƒ§å±ä¿æŠ¤æ‰“å¼€ï¼Œæ¯å¤©00:00~06:00åè‰² åƒåœ¾åŠŸèƒ½ï¼Œå¼Ÿä¸­å¼Ÿ
  364          // å‚æ•°: 
  365          // è¿”å›: æ— ï¼ˆOLED_InverseDisplay  1åè‰²  0æ­£å¸¸ï¼‰
  366          // ç‰ˆæœ¬: V1.0 2024.02.08
  367          //========================================================================
  368          void OLED_InverseDisplay2()
  369          {
  370   1          if(dat00[0x26])
  371   1          {
  372   2              if(((Time_New[2] >= 0x00) && (Time_New[2] < 0x06)) && (dat00[0x0021] > 0) && (OLED_InverseDisplay
             - == 0))
  373   2              {
  374   3                  OLED_WrCmd(0xa7);
  375   3                  OLED_InverseDisplay = 1;
  376   3              }
  377   2              else if((Time_New[2]>=0x06) && (dat00[0x0021]>0) && (OLED_InverseDisplay))
  378   2              {
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 7   

  379   3                  OLED_WrCmd(0xa6);
  380   3                  OLED_InverseDisplay = 0;
  381   3              }
  382   2          }
  383   1      }
  384          
  385          
  386          
  387          
  388          
  389          
  390          
  391          //========================================================================
  392          // å‡½æ•°: void OLED_Init(void)
  393          // æè¿°: OLEDåˆå§‹åŒ–ç¨‹åº
  394          // å‚æ•°: 
  395          // è¿”å›: 
  396          // ç‰ˆæœ¬: V1.0, 2024-02-29
  397          //========================================================================
  398          void OLED_Init(void)
  399          {
  400   1          RST=1;
  401   1          EA=0;
  402   1          //delay_ms(50);
  403   1          Sleep_delay_Time(100);
  404   1          RST=0;
  405   1          //delay_ms(50);
  406   1          Sleep_delay_Time(100);
  407   1          RST=1;
  408   1          //delay_ms(50);
  409   1          Sleep_delay_Time(80);
  410   1          EA = 1;
  411   1          OLED_WrCmd(0xae);//--turn off oled panel  å…³é—­oledé¢æ¿
  412   1          OLED_WrCmd(0x00);//---set low column address   è®¾ç½®ä½åˆ—åœ°å€
  413   1          OLED_WrCmd(0x10);//---set high column address   è®¾ç½®é«˜åˆ—åœ°å€
  414   1          OLED_WrCmd(0x40);//--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)   è®¾ç½®è
             -µ·å§‹è¡Œåœ°å€è®¾ç½®æ˜ å°„RAMæ˜¾ç¤ºèµ·å§‹è¡Œï¼ˆ0x00?0x3Fï¼‰
  415   1          OLED_WrCmd(0x81);//--set contrast controlregister  è®¾ç½®å¯¹æ¯”åº¦æ§åˆ¶å¯„å­˜å™¨
  416   1          OLED_WrCmd(Brightness); // Set SEG Output Current Brightness  è®¾ç½®SEGè¾“å‡ºç”µæµäº®åº¦
  417   1          OLED_WrCmd(0xa0);//--Set SEG/Column Mapping     0xa0å·¦å³åç½® 0xa1æ­£å¸¸
  418   1          OLED_WrCmd(0xc0);//Set COM/Row Scan Direction   0xc0ä¸Šä¸‹åç½® 0xc8æ­£å¸¸
  419   1          OLED_WrCmd(0xa6);//--set normal display     è®¾ç½®æ­£å¸¸æ˜¾ç¤º
  420   1          OLED_WrCmd(0xa8);//--set multiplex ratio(1 to 64)g    è®¾ç½®å¤ç”¨æ¯”ï¼ˆ1åˆ°64ï¼‰g
  421   1          OLED_WrCmd(0x3f);//--1/64 duty
  422   1          OLED_WrCmd(0xd3);//-set display offset  Shift Mapping RAM Counter (0x00~0x3F) è®¾ç½®æ˜¾ç¤ºåç§»é‡ç§»
             -ä½æ˜ å°„RAMè®¡æ•°å™¨ï¼ˆ0x00?0x3Fï¼‰
  423   1          OLED_WrCmd(0x00);//-not offset     ä¸æŠµæ¶ˆ
  424   1          OLED_WrCmd(0xd5);//--set display clock divide ratio/oscillator frequency  è®¾ç½®æ˜¾ç¤ºæ—¶é’Ÿåˆ†é¢‘æ¯”/
             -æŒ¯è¡å™¨é¢‘ç‡
  425   1          OLED_WrCmd(0x80);//--set divide ratio, Set Clock as 100 Frames/Sec    è®¾ç½®åˆ†é¢‘æ¯”ï¼Œå°†æ—¶é’Ÿè®¾ç½
             -®ä¸º100å¸§/ç§’   TVæ¨¡å¼ä½¿ç”¨0x10æˆ–0xF1 å…¶ä»–ç”¨0x80 æŒ‡å—é’ˆ0x50
  426   1          dat00[0x0007] = 0;
  427   1          OLED_WrCmd(0xd9);//--set pre-charge period       è®¾å®šé¢„å……ç”µæ—¶é—´
  428   1          OLED_WrCmd(0xf1);//Set Pre-Charge as 15 Clocks & Discharge as 1 Clock å°†é¢„å……ç”µè®¾ç½®ä¸º15ä¸ªæ—¶é’
             -Ÿå¹¶å°†æ”¾ç”µè®¾ç½®ä¸º1ä¸ªæ—¶é’Ÿ
  429   1          OLED_WrCmd(0xda);//--set com pins hardware configuration  è®¾ç½®comå¼•è„šçš„ç¡¬ä»¶é…ç½®
  430   1          OLED_WrCmd(0x12);
  431   1          OLED_WrCmd(0xdb);//--set vcomh
  432   1          OLED_WrCmd(0x40);//Set VCOM Deselect Level
  433   1          OLED_WrCmd(0x20);//-Set Page Addressing Mode (0x00/0x01/0x02) è®¾ç½®é¡µé¢å¯»å€æ¨¡å¼
  434   1          OLED_WrCmd(0x02);//
  435   1          OLED_WrCmd(0x8d);//--set Charge Pump enable   è®¾ç½®ç”µè·æ³µå¯ç”¨/ç¦ç”¨
  436   1          OLED_WrCmd(0x10);//--set(0x10)å¯ç”¨ (0x14)ç¦ç”¨
  437   1          OLED_WrCmd(0xa4);// Disable Entire Display On (0xa4/0xa5)ç¦ç”¨æ•´ä¸ªæ˜¾ç¤ºæ‰“å¼€
  438   1          OLED_WrCmd(0xa6);// Disable Inverse Display On (0xa6/a7)ç¦ç”¨åå‘æ˜¾ç¤ºæ‰“å¼€********
  439   1          OLED_WrCmd(0xaf);//--turn on oled panel
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 8   

  440   1          OLED_InverseDisplay2();
  441   1          OLED_Fill(0x00); //åˆå§‹æ¸…å±
  442   1          OLED_Set_Pos(0,0);
  443   1      }
  444          
  445          
  446          
  447          
  448          
  449          
  450          
  451          
  452          
  453          
  454          
  455          
  456          
  457          //========================================================================
  458          // å‡½æ•°: void ZF_8X8(u8 x,u8 y,u8 ee)
  459          // æè¿°: æ˜¾ç¤º8*8å¤§å°çš„å­—ç¬¦ï¼Œæ•°æ®æ¥æºï¼šF8x8
  460          // å‚æ•°:  xï¼šxåæ ‡ y:yåæ ‡ ee:ç¬¬å‡ ä¸ªå­—ç¬¦
  461          // è¿”å›:
  462          // ç‰ˆæœ¬: V1.0 2023.02.05
  463          //========================================================================
  464          void ZF_8X8(u8 x,u8 y,u8 ee)//
  465          {
  466   1          u8 i;
  467   1          u8 *SPI_dat;
  468   1          if(SPI_DMA_USE)
  469   1          {
  470   2              SPI_dat = SPI_DmaTxBuffer2;
  471   2          }
  472   1          else
  473   1          {
  474   2              SPI_dat = SPI_DmaTxBuffer;
  475   2          }
  476   1          for(i=0; i<8; i++)
  477   1          {
  478   2              SPI_dat[i] = F8x8[ee][i];
  479   2          }
  480   1          OLED_Set_Pos(x,y);
  481   1          SPI_DMA_switch();
  482   1          SPI_DMA_TX(7);
  483   1      }
  484          
  485          
  486          
  487          
  488          
  489          
  490          //========================================================================
  491          // å‡½æ•°: ZF_8X16(u8 x,u8 y,u8 ee)
  492          // æè¿°: æ˜¾ç¤º8*16å¤§å°çš„å­—ç¬¦ï¼Œæ•°æ®æ¥æºï¼šF8x16
  493          // å‚æ•°:  xï¼šxåæ ‡ y:yåæ ‡ ee:ç¬¬å‡ ä¸ªå­—ç¬¦
  494          // è¿”å›:
  495          // ç‰ˆæœ¬: V1.0 2023.02.05
  496          //========================================================================
  497          void ZF_8X16(u8 x,u8 y,u8 ee)//
  498          {
  499   1          u8 i;
  500   1          u8 k=0;
  501   1          u8 *SPI_dat;
  502   1          if(SPI_DMA_USE)
  503   1          {
  504   2              SPI_dat = SPI_DmaTxBuffer2;
  505   2          }
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 9   

  506   1          else
  507   1          {
  508   2              SPI_dat = SPI_DmaTxBuffer;
  509   2          }
  510   1          for(i=0; i<8; i++)
  511   1          {
  512   2              SPI_dat[i] = F8x16[ee][i];
  513   2          }
  514   1          OLED_Set_Pos(x,y);
  515   1          SPI_DMA_switch();
  516   1          SPI_DMA_TX(7);
  517   1      
  518   1      
  519   1          if(SPI_DMA_USE)
  520   1          {
  521   2              SPI_dat = SPI_DmaTxBuffer2;
  522   2          }
  523   1          else
  524   1          {
  525   2              SPI_dat = SPI_DmaTxBuffer;
  526   2          }
  527   1          for(; i<16; i++)
  528   1          {
  529   2              SPI_dat[k] = F8x16[ee][i];
  530   2              k++;
  531   2          }
  532   1          OLED_Set_Pos(x,(u8)(y+1));
  533   1          SPI_DMA_switch();
  534   1          SPI_DMA_TX(7);
  535   1      
  536   1      
  537   1      
  538   1      
  539   1      
  540   1      
  541   1      }
  542          //========================================================================
  543          // å‡½æ•°: void debug_8x8(int k,u8 x,u8 y)
  544          // æè¿°: ç”¨æ¥åœ¨å±å¹•ä¸Šæ‰“å°æ•°æ®ï¼Œ
  545          // å‚æ•°:  xï¼šxåæ ‡ y:yåæ ‡ k:éœ€è¦æ‰“å°çš„æ•°æ®ï¼ˆåªèƒ½æ˜¾ç¤º4ä½ï¼‰
  546          // è¿”å›:
  547          // ç‰ˆæœ¬: V1.0 2023.02.05
  548          //========================================================================
  549          void debug_8x8(int k,u8 x,u8 y)//
  550          {
  551   1          u8 i;
  552   1          u8 x1=x;
  553   1          OLED_Set_Pos(x,y);
  554   1          for(i=0; i<5; i++)
  555   1          {
  556   2              ZF_8X8(x1,y,10);
  557   2              x1=x1+8;
  558   2          }
  559   1          OLED_Set_Pos(x,y);
  560   1          if(k <0)
  561   1          {
  562   2      
  563   2              ZF_8X8(x,y,24);
  564   2              k= k*(-1);
  565   2          }
  566   1          else
  567   1          {
  568   2              ZF_8X8(x,y,10);
  569   2          }
  570   1          x=x+8;
  571   1      
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 10  

  572   1      
  573   1          ZF_8X8(x,y,(u8)(k / 1000));
  574   1          x=x+8;
  575   1      
  576   1          ZF_8X8(x,y,(u8)((k % 1000)/100));
  577   1          x=x+8;
  578   1      
  579   1          ZF_8X8(x,y,(u8)((k%100)/10));
  580   1          x=x+8;
  581   1          ZF_8X8(x,y,(u8)(k%10));
  582   1      
  583   1      }
  584          
  585          
  586          
  587          
  588          
  589          
  590          
  591          
  592          
  593          //========================================================================
  594          // å‡½æ•°: void nian(u16 ee,u8 y)
  595          // æè¿°: æ˜¾ç¤º8*16å¤§å°å­—ç¬¦çš„å¹´ä»½
  596          // å‚æ•°:  y:yåæ ‡ ee:å¹´ä»½
  597          // è¿”å›:
  598          // ç‰ˆæœ¬: V1.0 2023.02.05
  599          //========================================================================
  600          void nian(u16 ee,u8 y)
  601          {
  602   1          ZF_8X16(0,y,(u8)(ee / 1000));
  603   1          ZF_8X16(8,y,(u8)((ee % 1000)/100));
  604   1          ZF_8X16(16,y,(u8)((ee % 100)/10));
  605   1          ZF_8X16(24,y,(u8)(ee % 10));
  606   1          ZF_8X16(32,y,12);//æœ«å°¾å¸¦æ–œæ 
  607   1      }
  608          
  609          
  610          //========================================================================
  611          // å‡½æ•°: void yue_ri(u8 x,u8 ee,bit g)
  612          // æè¿°: æ˜¾ç¤º8*16å¤§å°å­—ç¬¦çš„æœˆä»½æˆ–è€…æ—¥
  613          // å‚æ•°: x:xåæ ‡ y:yåæ ‡ ee:æœˆ/æ—¥ g:æœ«å°¾æ˜¯å¦å¸¦æ–œæ 
  614          // è¿”å›:
  615          // ç‰ˆæœ¬: V1.0 2023.02.05
  616          //========================================================================
  617          void yue_ri(u8 x,u8 ee,bit g)
  618          {
  619   1          ZF_8X16(x,0,(u8)((ee % 100)/10));
  620   1          ZF_8X16((u8)(x+8),0,(u8)(ee % 10));
  621   1          if(g) ZF_8X16((u8)(x+16),0,12);
  622   1      }
  623          
  624          
  625          //========================================================================
  626          // å‡½æ•°: shifen(unsigned char t,unsigned char y)
  627          // æè¿°: æ˜¾ç¤º16*32å¤§å°å­—ç¬¦çš„æ—¶/åˆ†/ç§’
  628          // å‚æ•°: t:éœ€è¦æ˜¾ç¤ºçš„æ•°å­—/å­—ç¬¦ y:xåæ ‡
  629          // è¿”å›:
  630          // ç‰ˆæœ¬: V1.0  2023.02.05
  631          //========================================================================
  632          void shifen(unsigned char t,unsigned char y)//
  633          {
  634   1          unsigned char i;
  635   1          unsigned char j;
  636   1          unsigned char k;
  637   1          for(k=y; k<y+16; k=k+16)
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 11  

  638   1          {
  639   2              for(j=4; j<8; j++)
  640   2              {
  641   3                  OLED_Set_Pos(k,(u8)(j-1));
  642   3                  for(i=0; i<16; i++)
  643   3                  {
  644   4                      OLED_WrDat(F8x16d[t*4+j-4][i]);
  645   4                  }
  646   3              }
  647   2          }
  648   1      }
  649          
  650          
  651          
  652          
  653          
  654          //========================================================================
  655          // å‡½æ•°: shifen_2(unsigned char t,unsigned char y)
  656          // æè¿°: æ˜¾ç¤º16*32å¤§å°å­—ç¬¦çš„æ—¶/åˆ†/ç§’ï¼ˆç©ºå¿ƒï¼‰
  657          // å‚æ•°: t:éœ€è¦æ˜¾ç¤ºçš„æ•°å­—/å­—ç¬¦ y:xåæ ‡
  658          // è¿”å›:
  659          // ç‰ˆæœ¬: V1.0  2023.02.05
  660          //========================================================================
  661          void shifen_2(unsigned char t,unsigned char y)
  662          {
  663   1          unsigned char i;
  664   1          unsigned char j;
  665   1          unsigned char k;
  666   1          for(k=y; k<y+16; k=k+16)
  667   1          {
  668   2              for(j=4; j<8; j++)
  669   2              {
  670   3                  OLED_Set_Pos(k,(u8)(j-2));
  671   3                  for(i=0; i<16; i++)
  672   3                  {
  673   4                      OLED_WrDat(F16x32_hollow[t*4+j-4][i]);
  674   4                  }
  675   3              }
  676   2          }
  677   1      }
  678          
  679          
  680          
  681          
  682          //========================================================================
  683          // å‡½æ•°: OLED_16X16(u8 x,u8 y,u8 adde)
  684          // æè¿°: æ˜¾ç¤º16*16å¤§å°å­—ç¬¦çš„æ±‰å­—æˆ–è€…å…¶ä»–å­—ç¬¦æ˜¾ç¤ºï¼Œç”¨äºä¸»èœå•æ˜¾ç¤ºæ±‰å­—
  685          // å‚æ•°: x:xåæ ‡ y:yåæ ‡ adde:ç¬¬å‡ ä¸ªå­—ç¬¦
  686          // è¿”å›:
  687          // ç‰ˆæœ¬: V1.0  2023.02.05
  688          //========================================================================
  689          void OLED_16X16(u8 x,u8 y,u8 adde)
  690          {
  691   1          unsigned char i = 0;
  692   1          unsigned char j = 0;
  693   1          u8 *SPI_dat;
  694   1          adde = adde<<1;
  695   1          for(j=0; j<2; j++)
  696   1          {
  697   2              if(SPI_DMA_USE)
  698   2              {
  699   3                  SPI_dat = SPI_DmaTxBuffer2;
  700   3              }
  701   2              else
  702   2              {
  703   3                  SPI_dat = SPI_DmaTxBuffer;
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 12  

  704   3              }
  705   2              for(i=0; i<16; i++)
  706   2              {
  707   3                  SPI_dat[i]= F16x16cd[adde][i];
  708   3              }
  709   2              OLED_Set_Pos(x,y);
  710   2              SPI_DMA_switch();
  711   2              SPI_DMA_TX(15);
  712   2              adde++;
  713   2              y++;
  714   2          }
  715   1      }
  716          
  717          
  718          
  719          
  720          //========================================================================
  721          // å‡½æ•°: void OLED_8X8X3_MOV(u8 x,u8 y,u16 adde,u8 devia1,u8 devia2)
  722          // æè¿°: æŒ‡å—é’ˆæ ‡å°ºæ‰€ç”¨ï¼Œæ˜¾ç¤º3ä½è§’åº¦åœ¨æ ‡å°ºä¸Š
  723          // å‚æ•°: å¿˜äº†å•¥æ„æ€äº†ï¼Œ  devia1ï¼šä»ç¬¬åˆ—å¼€å§‹ç”»  devia2ï¼šç”»åˆ°ç¬¬å‡ ä¸ª
  724          // è¿”å›:
  725          // ç‰ˆæœ¬: V1.0  2023.02.05
  726          //========================================================================
  727          void OLED_8X8X3_MOV(u8 x,u8 y,u16 adde,u8 devia1,u8 devia2)
  728          {
  729   1          unsigned char i = 0;
  730   1          unsigned char j = 0;
  731   1          if(devia1 > 24) devia1 =0;
  732   1          if(devia2 > 24) devia2 =24;
  733   1          if(x >= 244)
  734   1          {
  735   2              devia1 = 256 - x;
  736   2              x = 0;
  737   2          }
  738   1          if(x < 128 && devia1 < 24 && devia2 <= 24)
  739   1          {
  740   2              for(i=0; i<24; i++)
  741   2              {
  742   3                  UI_TX[0][i] = 0x00;
  743   3              }
  744   2      
  745   2              if(adde<10)
  746   2              {
  747   3                  for(i=0; i<8; i++)
  748   3                  {
  749   4                      UI_TX[0][8+i] = F8x8[(adde % 10)][i];
  750   4                  }
  751   3              }
  752   2              else if(adde<100)
  753   2              {
  754   3                  for(i=0; i<8; i++)
  755   3                  {
  756   4                      UI_TX[0][4+i] = F8x8[((adde %100) / 10)][i];
  757   4                  }
  758   3                  for(i=0; i<8; i++)
  759   3                  {
  760   4                      UI_TX[0][12+i] = F8x8[(adde %10)][i];
  761   4                  }
  762   3              }
  763   2              else if(adde<1000)
  764   2              {
  765   3                  for(i=0; i<8; i++)
  766   3                  {
  767   4                      UI_TX[0][i] = F8x8[(adde / 100)][i];
  768   4                  }
  769   3                  for(i=0; i<8; i++)
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 13  

  770   3                  {
  771   4                      UI_TX[0][8+i] = F8x8[((adde %100) / 10)][i];
  772   4                  }
  773   3                  for(i=0; i<8; i++)
  774   3                  {
  775   4                      UI_TX[0][16+i] = F8x8[(adde %10)][i];
  776   4                  }
  777   3              }
  778   2              OLED_Set_Pos(x,y);
  779   2              for(i=devia1; i<devia2; i++)
  780   2              {
  781   3                  OLED_WrDat(UI_TX[0][i]);
  782   3              }
  783   2          }
  784   1      }
  785          
  786          
  787          
  788          
  789          
  790          //========================================================================
  791          // å‡½æ•°: void OLED_16X16_MOV(u8 x,u8 y,u8 adde,u8 devia1,u8 devia2)
  792          // æè¿°: æŒ‡å—é’ˆæ ‡å°ºæ‰€ç”¨ï¼Œæ˜¾ç¤ºä¸œå—è¥¿åŒ—æ±‰å­—åœ¨æ ‡å°ºä¸Š
  793          // å‚æ•°: ä¹Ÿå¿˜äº†å•¥æ„æ€äº†ï¼Œå’Œ8X8X3_MOVä¸€æ · devia1ï¼šä»ç¬¬åˆ—å¼€å§‹ç”»  devia2ï¼šç”»åˆ°ç¬¬å‡ ä
             -¸ª
  794          // è¿”å›:
  795          // ç‰ˆæœ¬: V1.0  2023.02.05
  796          //========================================================================
  797          void OLED_16X16_MOV(u8 x,u8 y,u8 adde,u8 devia1,u8 devia2)
  798          {
  799   1          unsigned char i = 0;
  800   1          unsigned char j = 0;
  801   1      
  802   1          if(devia1 > 16) devia1 =0;
  803   1          if(devia2 > 16) devia2 =16;
  804   1          if(x >= 248)
  805   1          {
  806   2              devia1 = 256 - x;
  807   2              x = 0;
  808   2          }
  809   1      
  810   1          if(x < 128 && devia1 < 16 && devia2 <= 16)
  811   1          {
  812   2              adde = adde<<1;
  813   2              for(j=0; j<2; j++)
  814   2              {
  815   3                  OLED_Set_Pos(x,y);
  816   3                  for(i=devia1; i<devia2; i++)
  817   3                  {
  818   4                      OLED_WrDat(F16x16_position[adde][i]);
  819   4                  }
  820   3                  adde++;
  821   3                  y++;
  822   3              }
  823   2          }
  824   1      }
  825          
  826          
  827          
  828          //========================================================================
  829          // å‡½æ•°: void OLED_32X32(u8 x,u8 y,u8 addr,u8 devia1,u8 devia2)
  830          // æè¿°: ä¸»èœå•å›¾æ ‡æ˜¾ç¤º
  831          // å‚æ•°: xï¼šxåæ ‡  yï¼šyåæ ‡  addrï¼šå›¾æ ‡æŒ‡å‘ devia1ï¼šä»ç¬¬åˆ—å¼€å§‹ç”»  devia2ï¼šç”»åˆ°ç¬¬å
             -‡ ä¸ª
  832          // è¿”å›:
  833          // ç‰ˆæœ¬: V1.0  2023.02.05
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 14  

  834          //========================================================================
  835          void OLED_32X32(u8 x,u8 y,u8 addr,u8 devia1,u8 devia2)
  836          {
  837   1          u8 i = 0;
  838   1          u8 j = 0;
  839   1          u8 k=0;
  840   1          u8 *SPI_dat;
  841   1          if(x < 128 && devia1 < 32 && devia2 <= 32)
  842   1          {
  843   2              addr = addr<<2;
  844   2              for(j=0; j<4; j++)
  845   2              {
  846   3      
  847   3                  k=0;
  848   3                  if(SPI_DMA_USE)
  849   3                  {
  850   4                      SPI_dat = SPI_DmaTxBuffer2;
  851   4                  }
  852   3                  else
  853   3                  {
  854   4                      SPI_dat = SPI_DmaTxBuffer;
  855   4                  }
  856   3                  for(i=devia1; i<devia2; i++)
  857   3                  {
  858   4                      SPI_dat[k]   = F32x32[addr][i];
  859   4                      k++;
  860   4                  }
  861   3                  OLED_Set_Pos(x,y);
  862   3                  SPI_DMA_switch();
  863   3                  SPI_DMA_TX((u8)(k-1));
  864   3                  addr++;
  865   3                  y++;
  866   3              }
  867   2          }
  868   1      }
  869          
  870          
  871          //========================================================================
  872          // å‡½æ•°: void OLED_ED()
  873          // æè¿°: å…³é—­OLEDæ˜¾ç¤º
  874          // å‚æ•°:
  875          // è¿”å›:
  876          // ç‰ˆæœ¬: V1.0  2023.02.05
  877          //========================================================================
  878          void OLED_ED()
  879          {
  880   1          OLED_WrCmd(0xae);//--turn off oled panel  å…³é—­oledé¢æ¿
  881   1      
  882   1      }
  883          
  884          //========================================================================
  885          // å‡½æ•°: void OLED_GD()
  886          // æè¿°: ä¸»èœå•æ»šåŠ¨ï¼Œå¥½åƒæ²¡ç”¨ä¸Š
  887          // å‚æ•°:
  888          // è¿”å›:
  889          // ç‰ˆæœ¬: V1.0  2023.02.05
  890          //========================================================================
  891          void OLED_GD()
  892          {
  893   1          unsigned char i;
  894   1          unsigned char j = 0;
  895   1          unsigned char k = 48;
  896   1          unsigned char y = 0;
  897   1          unsigned char t = 0;
  898   1      
  899   1          for(j=0; j<4; j++)
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 15  

  900   1          {
  901   2              OLED_Set_Pos(k,j);
  902   2              for(i=0; i<32; i++)
  903   2              {
  904   3                  OLED_WrDat(F32x32[j][i]);
  905   3              }
  906   2          }
  907   1          k = 96;
  908   1          for(j=0; j<4; j++)
  909   1          {
  910   2              OLED_Set_Pos(k,j);
  911   2              for(i=0; i<32; i++)
  912   2              {
  913   3                  OLED_WrDat(F32x32[j+4][i]);
  914   3              }
  915   2          }
  916   1          k = 0;
  917   1          for(j=0; j<4; j++)
  918   1          {
  919   2              OLED_Set_Pos(k,j);
  920   2              for(i=0; i<32; i++)
  921   2              {
  922   3                  OLED_WrDat(F32x32[j+36][i]);
  923   3              }
  924   2          }
  925   1      }
  926          
  927          
  928          
  929          
  930          
  931          //========================================================================
  932          // å‡½æ•°: void OLED_3Figures(u16 num,u8 x,u8 y)
  933          // æè¿°: æŒ‡å—é’ˆæ˜¾ç¤ºè§’åº¦æ•°å€¼ï¼Œè‡ªåŠ¨å±…ä¸­ï¼ˆå¥½åƒæœ‰ç‚¹é—®é¢˜ï¼Œä½ ä»¬è‡ªå·±ä¿®ä¸€ä¸‹ç¬‘æ­»ï
             -¼‰
  934          // å‚æ•°:
  935          // è¿”å›:
  936          // ç‰ˆæœ¬: V1.0  2023.02.05
  937          //========================================================================
  938          
  939          void OLED_3Figures(u16 num,u8 x,u8 y)
  940          {
  941   1          u8 a = 0;
  942   1          u8 b = 0;
  943   1          u8 c = 0;
  944   1          u8 i = 0;
  945   1          u8 p = 0;
  946   1      
  947   1          a = (u8)((num % 1000)/100);
  948   1          b = (u8)((num % 100)/10);
  949   1          c = (u8)(num % 10);
  950   1          p = numlongGet(num);
  951   1      
  952   1          if(p <= 2)
  953   1          {
  954   2              ZF_8X16(x,y,10);
  955   2              ZF_8X16((u8)(x+16),y,10);
  956   2          }
  957   1      
  958   1      
  959   1      
  960   1      
  961   1          if(p == 3)
  962   1          {
  963   2              ZF_8X16(x,y,a);
  964   2          }
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 16  

  965   1          if(p >= 2)
  966   1          {
  967   2              x = x + 8;
  968   2              if(p == 2) x = x+4;
  969   2              ZF_8X16(x,y,b);
  970   2          }
  971   1          if(p >= 1)
  972   1          {
  973   2              x = x + 8;
  974   2              if(p == 1) x = x+12;
  975   2              ZF_8X16(x,y,c);
  976   2          }
  977   1      
  978   1      
  979   1      
  980   1      }
  981          
  982          
  983          
  984          
  985          
  986          
  987          //========================================================================
  988          // å‡½æ•°: void OLED_Progress_Bar(u16 num,u16 jx)
  989          // æè¿°: ä¸‰çº§èœå•è¿›åº¦æ¡
  990          // å‚æ•°: numï¼šå½“å‰å€¼  jxï¼šæœ€å¤§å€¼
  991          // è¿”å›:
  992          // ç‰ˆæœ¬: V1.0  2023.02.05
  993          //========================================================================
  994          void OLED_Progress_Bar(u16 num,u16 jx)
  995          {
  996   1          u8 i;
  997   1          u8 j;
  998   1          u8 k;
  999   1          if(num <= jx)
 1000   1          {
 1001   2              j = ((u16)num * 60)/jx;
 1002   2              OLED_Set_Pos(18,5);
 1003   2              OLED_WrDat(0xff);
 1004   2      
 1005   2              for(i=0; i<j; i++)
 1006   2              {
 1007   3                  OLED_WrDat(0xff);
 1008   3              }
 1009   2              k=60-j;
 1010   2              for(i=0; i<k; i++)
 1011   2              {
 1012   3                  OLED_WrDat(0x81);
 1013   3              }
 1014   2      
 1015   2              OLED_WrDat(0xff);
 1016   2              k = (u8)((num % 1000)/100);
 1017   2              if(k!=0)
 1018   2              {
 1019   3                  ZF_8X8(82,5,k);
 1020   3              }
 1021   2              else
 1022   2              {
 1023   3                  ZF_8X8(82,5,0x0A);
 1024   3              }
 1025   2      
 1026   2              j = (u8)((num % 100)/10);
 1027   2              if(k==0 && j==0)
 1028   2              {
 1029   3                  ZF_8X8(90,5,0x0A);
 1030   3              }
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 17  

 1031   2              else
 1032   2              {
 1033   3                  ZF_8X8(90,5,j);
 1034   3              }
 1035   2              ZF_8X8(98,5,(u8)(num % 10));
 1036   2          }
 1037   1      }
 1038          
 1039          
 1040          
 1041          
 1042          //========================================================================
 1043          // å‡½æ•°:void OLED_Region_Fill()
 1044          // æè¿°: ç»˜åˆ¶ä¸€ä¸ªå¸¦è¾¹çš„çª—å£ï¼Œç”¨äºä¸‰çº§èœå•
 1045          // å‚æ•°: 
 1046          // è¿”å›:
 1047          // ç‰ˆæœ¬: V1.0  2023.02.05
 1048          //========================================================================
 1049          void OLED_Region_Fill()
 1050          {
 1051   1          u8 k;
 1052   1          u8 q;
 1053   1          u8 i;
 1054   1          for(k=0; k<6; k++)
 1055   1          {
 1056   2              OLED_Set_Pos(16,(u8)(1+k));
 1057   2              for(i=0; i<96; i++)
 1058   2              {
 1059   3                  if(k == 0)
 1060   3                  {
 1061   4                      q = 0x01;
 1062   4                  }
 1063   3                  else if(k == 5)
 1064   3                  {
 1065   4                      q = 0x80;
 1066   4                  }
 1067   3                  else
 1068   3                  {
 1069   4                      q=0;
 1070   4                  }
 1071   3                  if((i == 0) | (i == (95)))
 1072   3                  {
 1073   4                      q=0xff;
 1074   4                  }
 1075   3                  OLED_WrDat(q);
 1076   3              }
 1077   2          }
 1078   1      }
 1079          
 1080          
 1081          
 1082          //**********************************************************************
 1083          //
 1084          //    ç¬¬äºŒèœå•åŠŸèƒ½åŒº
 1085          //
 1086          //**********************************************************************
 1087          
 1088          
 1089          
 1090          //========================================================================
 1091          // å‡½æ•°:void OLED_FZQP(u8 x,u8 y)
 1092          // æè¿°: æ¸…ç©ºä¸€ä¸ªåŒºåŸŸï¼ˆäºŒçº§èœå•æ»šåŠ¨ç»“æŸåå¯èƒ½å¦‚æœå›¾æ¡ˆå®šæ ¼çš„è¯ä¼šæœ‰æ®‹ç•™ï¼‰
 1093          // å‚æ•°: 
 1094          // è¿”å›:
 1095          // ç‰ˆæœ¬: V1.0  2023.02.05
 1096          //========================================================================
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 18  

 1097          void OLED_FZQP(u8 x,u8 y)
 1098          {
 1099   1          u8 i = 0;
 1100   1          OLED_Set_Pos(x,y);
 1101   1          for(i=0; i<64; i++)
 1102   1          {
 1103   2              OLED_WrDat(0x00);
 1104   2          }
 1105   1      
 1106   1      }
 1107          
 1108          //========================================================================
 1109          // å‡½æ•°: void OLED_16_16V(u8 (*dat)[16],u16 adde,u8 x,u8 y,bit p)
 1110          // æè¿°: (*dat)[16]ï¼šç‚¹é˜µ  addeï¼šäºŒç»´æ•°ç»„ç¬¬å‡ è¡Œ x:xåæ ‡ y:yåæ ‡ p ï¼šæ˜¯å¦åè‰²ï¼Œç”¨ä
             -ºåšå…‰æ ‡
 1111          // å‚æ•°: 
 1112          // è¿”å›:
 1113          // ç‰ˆæœ¬: V1.0  2023.02.05
 1114          //========================================================================
 1115          void OLED_16_16V(u8 (*dat)[16],u16 adde,u8 x,u8 y,bit p)
 1116          {
 1117   1          u8 i = 0;
 1118   1          u8 j = 0;
 1119   1          u8 k=0;
 1120   1          u8 *SPI_dat;
 1121   1          j = adde;
 1122   1          adde = adde + 8;
 1123   1      
 1124   1          k=0;
 1125   1          if(SPI_DMA_USE)
 1126   1          {
 1127   2              SPI_dat = SPI_DmaTxBuffer2;
 1128   2          }
 1129   1          else
 1130   1          {
 1131   2              SPI_dat = SPI_DmaTxBuffer;
 1132   2          }
 1133   1          for(; j<adde; j = j + 2)
 1134   1          {
 1135   2              for(i=0; i<16; i++)
 1136   2              {
 1137   3                  if(p)
 1138   3                  {
 1139   4                      SPI_dat[k] = dat[j][i];
 1140   4                  }
 1141   3                  else
 1142   3                  {
 1143   4                      SPI_dat[k] = ~dat[j][i];
 1144   4                  }
 1145   3                  k++;
 1146   3              }
 1147   2          }
 1148   1          OLED_Set_Pos(x,y);
 1149   1          SPI_DMA_switch();
 1150   1          SPI_DMA_TX((u8)(k-1));
 1151   1      }
 1152          
 1153          
 1154          
 1155          //========================================================================
 1156          // å‡½æ•°: void OLED_16_16Vabc(u8 (*dat)[16],u16 adde,u8 x,u8 y,u8 c,bit jj,u8 Number)
 1157          // æè¿°: æ˜¾ç¤ºåŠè¡Œï¼ˆå·¦å³ï¼‰äºŒçº§èœå•
 1158          // å‚æ•°: (*dat)[16]ï¼šç‚¹é˜µ  addeï¼šäºŒç»´æ•°ç»„ç¬¬å‡ è¡Œ x:xåæ ‡ y:yåæ ‡ c:å¿˜äº†ï¼Œå¥½åƒæ˜¯0å°±
             -ä¸å‘ä¸Šèµ°é¡¶å‡ºå±å¹•ï¼Œç”¨åœ¨ç¬¬ä¸€ä¸ªé€‰é¡¹  jjï¼šå¿˜äº† Numberï¼šæˆ‘ä¹Ÿå¿˜äº†ä¸ºä»€ä¹ˆä¸€å®šè¦å†™8äº†
 1159          //                                                                                                       
             -    ä½ ä»¬å¯ä»¥å†™ä¸åŒçš„å€¼è¯•è¯•æ•ˆæœ
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 19  

 1160          // è¿”å›:
 1161          // ç‰ˆæœ¬: V1.0  2023.02.05
 1162          //========================================================================
 1163          void OLED_16_16Vabc(u8 (*dat)[16],u16 adde,u8 x,u8 y,u8 c,bit jj,u8 Number)
 1164          {
 1165   1          u8 i = 0;
 1166   1          u8 j = 0;
 1167   1          u16 t = 0;
 1168   1      
 1169   1          y = (u8)(y/8);
 1170   1          j = adde;
 1171   1          adde = adde + Number;
 1172   1          if(jj) c = c % 8;
 1173   1          if(y < 8)
 1174   1          {
 1175   2              OLED_Set_Pos(x,y);
 1176   2              for(; j<adde; j = j + 2)
 1177   2              {
 1178   3                  for(i=0; i<16; i++)
 1179   3                  {
 1180   4                      if(!jj)
 1181   4                      {
 1182   5                          t = dat[j+1][i]*256+dat[j][i];
 1183   5                          OLED_WrDat((u8)(t >> c));
 1184   5                      }
 1185   4                      else
 1186   4                      {
 1187   5                          t = dat[j][i];
 1188   5                          OLED_WrDat((u8)(t << c));
 1189   5                      }
 1190   4      
 1191   4                  }
 1192   3      
 1193   3              }
 1194   2          }
 1195   1          y = (u8)(y+1);
 1196   1          j = adde  - (Number - 1);
 1197   1          adde = adde + 1;
 1198   1          if(y < 8)
 1199   1          {
 1200   2              OLED_Set_Pos(x,y);
 1201   2              for(; j<adde; j = j + 2)
 1202   2              {
 1203   3                  for(i=0; i<16; i++)
 1204   3                  {
 1205   4                      if(!jj)
 1206   4                      {
 1207   5                          t = dat[j][i];
 1208   5                          OLED_WrDat((u8)(t >> c));
 1209   5                      }
 1210   4                      else
 1211   4                      {
 1212   5                          t = dat[j][i]*256+dat[j-1][i];
 1213   5                          OLED_WrDat((u8)(t >> (8 - c)));
 1214   5                      }
 1215   4                  }
 1216   3              }
 1217   2          }
 1218   1          y = (u8)(y+1);
 1219   1          j = adde  - Number;
 1220   1          if(y < 8)
 1221   1          {
 1222   2              OLED_Set_Pos(x,y);
 1223   2              for(; j<adde; j = j + 2)
 1224   2              {
 1225   3                  for(i=0; i<16; i++)
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 20  

 1226   3                  {
 1227   4                      if(!jj)
 1228   4                      {
 1229   5      
 1230   5                      }
 1231   4                      else
 1232   4                      {
 1233   5                          t = dat[j][i];
 1234   5                          OLED_WrDat((u8)(t >> (8 - c)));
 1235   5                      }
 1236   4                  }
 1237   3              }
 1238   2      
 1239   2      
 1240   2          }
 1241   1      
 1242   1      
 1243   1      //u8 i = 0;
 1244   1      //    u8 j = 0;
 1245   1      //    u16 t = 0;
 1246   1      //    u8 k=0;
 1247   1      //    u8 *SPI_dat;
 1248   1      //    y = (u8)(y/8);
 1249   1      //    j = adde;
 1250   1      //    adde = adde + Number;
 1251   1      //    if(jj) c = c % 8;
 1252   1      //    if(y < 8)
 1253   1      //    {
 1254   1      //        k=0;
 1255   1      //        if(SPI_DMA_USE)
 1256   1      //        {
 1257   1      //            SPI_dat = SPI_DmaTxBuffer2;
 1258   1      //        }
 1259   1      //        else
 1260   1      //        {
 1261   1      //            SPI_dat = SPI_DmaTxBuffer;
 1262   1      //        }
 1263   1      //        for(; j<adde; j = j + 2)
 1264   1      //        {
 1265   1      //            for(i=0; i<16; i++)
 1266   1      //            {
 1267   1      //                if(!jj)
 1268   1      //                {
 1269   1      //                    t = dat[j+1][i]*256+dat[j][i];
 1270   1      //                    SPI_dat[k]=((u8)(t >> c));
 1271   1      //                }
 1272   1      //                else
 1273   1      //                {
 1274   1      //                    t = dat[j][i];
 1275   1      //                    SPI_dat[k]=((u8)(t << c));
 1276   1      //                }
 1277   1      //                k++;
 1278   1      //            }
 1279   1      
 1280   1      //        }
 1281   1      //        OLED_Set_Pos(x,y);
 1282   1      //        SPI_DMA_switch();
 1283   1      //        SPI_DMA_TX((u8)(k-1));
 1284   1      //
 1285   1      //
 1286   1      //
 1287   1      //    }
 1288   1      //    y = (u8)(y+1);
 1289   1      //    j = adde  - (Number - 1);
 1290   1      //    adde = adde + 1;
 1291   1      //    if(y < 8)
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 21  

 1292   1      //    {
 1293   1      //        k=0;
 1294   1      //        if(SPI_DMA_USE)
 1295   1      //        {
 1296   1      //            SPI_dat = SPI_DmaTxBuffer2;
 1297   1      //        }
 1298   1      //        else
 1299   1      //        {
 1300   1      //            SPI_dat = SPI_DmaTxBuffer;
 1301   1      //        }
 1302   1      //        for(; j<adde; j = j + 2)
 1303   1      //        {
 1304   1      //            for(i=0; i<16; i++)
 1305   1      //            {
 1306   1      //                if(!jj)
 1307   1      //                {
 1308   1      //                    t = dat[j][i];
 1309   1      //                    SPI_dat[k]=((u8)(t >> c));
 1310   1      //                }
 1311   1      //                else
 1312   1      //                {
 1313   1      //                    t = dat[j][i]*256+dat[j-1][i];
 1314   1      //                    SPI_dat[k]=((u8)(t >> (8 - c)));
 1315   1      //                }
 1316   1      //                k++;
 1317   1      //            }
 1318   1      //
 1319   1      //        }
 1320   1      //        OLED_Set_Pos(x,y);
 1321   1      //        SPI_DMA_switch();
 1322   1      //        SPI_DMA_TX((u8)(k-1));
 1323   1      //    }
 1324   1      //    y = (u8)(y+1);
 1325   1      //    j = adde  - Number;
 1326   1      //    if(y < 8)
 1327   1      //    {
 1328   1      //        k=0;
 1329   1      //        if(SPI_DMA_USE)
 1330   1      //        {
 1331   1      //            SPI_dat = SPI_DmaTxBuffer2;
 1332   1      //        }
 1333   1      //        else
 1334   1      //        {
 1335   1      //            SPI_dat = SPI_DmaTxBuffer;
 1336   1      //        }
 1337   1      //        for(; j<adde; j = j + 2)
 1338   1      //        {
 1339   1      //            for(i=0; i<16; i++)
 1340   1      //            {
 1341   1      //                if(!jj)
 1342   1      //                {
 1343   1      //                      SPI_dat[k]=0x00;
 1344   1      //                }
 1345   1      //                else
 1346   1      //                {
 1347   1      //                    t = dat[j][i];
 1348   1      //                    SPI_dat[k]=((u8)(t >> (8 - c)));
 1349   1      //                }
 1350   1      //                k++;
 1351   1      //            }
 1352   1      //
 1353   1      //        }
 1354   1      //        OLED_Set_Pos(x,y);
 1355   1      //        SPI_DMA_switch();
 1356   1      //        SPI_DMA_TX((u8)(k-1));
 1357   1      
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 22  

 1358   1      //    }
 1359   1      
 1360   1      
 1361   1      
 1362   1      }
 1363          
 1364          //========================================================================
 1365          // å‡½æ•°: u8** TVR(u8 i)
 1366          // æè¿°: æ˜¾ç¤ºæ•°ç»„æ˜ å°„å‡½æ•°ï¼Œç”¨äºç›´æ¥ç”¨å…‰æ ‡ç›´æ¥æŒ‡ç¤ºå¯¹åº”çš„ç‚¹é˜µ
 1367          // å‚æ•°:  iï¼šå…‰æ ‡çš„å€¼                                                                             
             -                        
 1368          // è¿”å›:  **pp éœ€è¦æ˜¾ç¤ºçš„ç‚¹é˜µ 
 1369          // ç‰ˆæœ¬: V1.0  2023.02.05
 1370          //========================================================================
 1371          u8** TVR(u8 i)
 1372          {
 1373   1          u8 **pp ;
 1374   1      
 1375   1          switch (i)
 1376   1          {
 1377   2          case 0x0000:
 1378   2              pp = TVMode_16;//æ ‡å‡†æ¨¡å¼
 1379   2              break;
 1380   2          case 0x0001:
 1381   2              pp = SleepMode_16;//æ ‡å‡†æ¨¡å¼
 1382   2              break;
 1383   2          case 0x0002 :
 1384   2              pp = Environment;//ç¯å¢ƒå‚æ•°
 1385   2              break;
 1386   2          case 0x0003 :
 1387   2              pp = Brightness_setting;//äº®åº¦è®¾ç½®
 1388   2              break;
 1389   2          case 0x0004 :
 1390   2              pp = CompassMenu_16;//æŒ‡å—é’ˆ
 1391   2              break;
 1392   2      
 1393   2          case 0x0006 :
 1394   2              pp = time_set;//æ—¶é—´è®¾ç½®
 1395   2              break;
 1396   2      
 1397   2          case 0x000A :
 1398   2              pp = Sound_setting;//å£°éŸ³è®¾ç½®
 1399   2              break;
 1400   2          case 0x000C :
 1401   2              pp = Power_Options;//ç”µæºç®¡ç†
 1402   2              break;
 1403   2          case 0x000E :
 1404   2              pp = System_Information;//ç³»ç»Ÿä¿¡æ¯
 1405   2              break;
 1406   2      
 1407   2      
 1408   2          case 0x0040 :
 1409   2              pp = System_Information_data;//ç³»ç»Ÿä¿¡æ¯æ•°æ®
 1410   2              break;
 1411   2      
 1412   2      
 1413   2      
 1414   2      
 1415   2          case 0x0060 :
 1416   2              pp = UI_dat;//ç³»ç»Ÿä¿¡æ¯æ•°æ®
 1417   2              break;
 1418   2      
 1419   2      
 1420   2          case 0x0080 :
 1421   2              pp = F8x16d;
 1422   2              break;
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 23  

 1423   2      
 1424   2          default:
 1425   2              pp = TVMode_16;
 1426   2              break;
 1427   2      
 1428   2          }
 1429   1          return pp;
 1430   1      
 1431   1      }
 1432          
 1433          
 1434          
 1435          
 1436          
 1437          
 1438          //========================================================================
 1439          // å‡½æ•°: void OLED_16_16V2(u8 (*dat)[16],u16 adde,u8 x,u8 y,bit p)
 1440          // æè¿°: æ²¡ç”¨åˆ°ï¼Œå¥½åƒä¹‹å‰æ˜¯äºŒçº§èœå•æ˜¾ç¤ºçš„ï¼Œåæ¥ä¸ºäº†èƒ½è‡ªå®šä¹‰å›¾æ¡ˆå°±æ¢äº†ä¸ªæ
             -–¹æ³•å®ç°
 1441          // å‚æ•°:                                                                                              
 1442          // è¿”å›:  
 1443          // ç‰ˆæœ¬: V1.0  2023.02.05
 1444          //========================================================================
 1445          
 1446          void OLED_16_16V2(u8 (*dat)[16],u16 adde,u8 x,u8 y,bit p)
 1447          {
 1448   1      
 1449   1          OLED_16_16V(dat,adde,x,y,p);
 1450   1          adde = adde + 1;
 1451   1          OLED_16_16V(dat,adde,x,(u8)(y+1),p);
 1452   1          OLED_FZQP(0,5);
 1453   1      
 1454   1      }
 1455          
 1456          
 1457          //========================================================================
 1458          // å‡½æ•°: void OLED_Mean2_fill(u8 p,u8 a)
 1459          // æè¿°: UI_datæ•°ç»„é‡Œé¢å…¨éƒ¨å¡«å……ä¸€ä¸ªæ•°ï¼Œå¹³æ—¶ç”¨æ¥æ¸…ç©º
 1460          // å‚æ•°:                                                                                              
 1461          // è¿”å›:  
 1462          // ç‰ˆæœ¬: V1.0  2023.02.05
 1463          //========================================================================
 1464          
 1465          void OLED_Mean2_fill(u8 p,u8 a)
 1466          {
 1467   1          u8 i;
 1468   1          u8 j;
 1469   1          if(p<=8)
 1470   1          {
 1471   2              for(j = 0; j <p ; j++)
 1472   2              {
 1473   3                  for(i = 0; i <16 ; i++)
 1474   3                  {
 1475   4                      UI_dat[j][i] = a;
 1476   4                  }
 1477   3              }
 1478   2          }
 1479   1      }
 1480          
 1481          
 1482          //========================================================================
 1483          // å‡½æ•°: void OLED_Mean2_fill2(u8 a)
 1484          // æè¿°: UI_datæ•°ç»„é‡Œé¢å…¨éƒ¨å¡«å……ä¸€ä¸ªå¼€å…³å›¾å½¢ï¼Œ
 1485          // å‚æ•°: aï¼šæ‰“å¼€è¿˜æ˜¯å…³é—­                                                                        
             -                    
 1486          // è¿”å›:  
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 24  

 1487          // ç‰ˆæœ¬: V1.0  2023.02.05
 1488          //========================================================================
 1489          void OLED_Mean2_fill2(u8 a)
 1490          {
 1491   1          u8 i;
 1492   1          u8 j;
 1493   1          u8 (*pa)[16];
 1494   1      
 1495   1          if(a>0)
 1496   1          {
 1497   2              pa = KG_K;
 1498   2          }
 1499   1          else
 1500   1          {
 1501   2              pa = KG_G;
 1502   2      
 1503   2          }
 1504   1          for(j = 0; j <4 ; j++)
 1505   1          {
 1506   2              for(i = 0; i <16 ; i++)
 1507   2              {
 1508   3                  UI_dat[j+4][i] = pa[j][i];
 1509   3              }
 1510   2          }
 1511   1          OLED_Mean2_fill(4,0);
 1512   1      }
 1513          
 1514          
 1515          
 1516          //========================================================================
 1517          // å‡½æ•°: void ZQ8x8(u8 a,u8 dat)
 1518          // æè¿°: UI_datæ•°ç»„é‡Œé¢å…¨éƒ¨å¡«å……ä¸€ä¸ª8*8æ•°å­—ï¼Œ
 1519          // å‚æ•°:                                                                                       
 1520          // è¿”å›:  
 1521          // ç‰ˆæœ¬: V1.0  2023.02.05
 1522          //========================================================================
 1523          void ZQ8x8(u8 a,u8 dat)
 1524          {
 1525   1          u8 i=0;
 1526   1          u8 p=0;
 1527   1          u8 b=0;
 1528   1          p = dat / 10;
 1529   1          for(i = 0; i <8 ; i++)
 1530   1          {
 1531   2              UI_dat[a][i] = F8x8_2[p][i];
 1532   2          }
 1533   1          p = dat % 10;
 1534   1          for(; i <16 ; i++)
 1535   1          {
 1536   2              UI_dat[a][i] = F8x8_2[p][b];
 1537   2              b++;
 1538   2          }
 1539   1      
 1540   1      }
 1541          
 1542          
 1543          
 1544          
 1545          
 1546          //========================================================================
 1547          // å‡½æ•°: u8 numlongGet(u16 a)
 1548          // æè¿°: è·å–è¿™ä¸ªæ•°æ®æ˜¯å‡ ä½çš„æ•°æ®
 1549          // å‚æ•°:                                                                                       
 1550          // è¿”å›:  
 1551          // ç‰ˆæœ¬: V1.0  2023.02.05
 1552          //========================================================================
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 25  

 1553          u8 numlongGet(u16 a)
 1554          {
 1555   1          if(a >= 10000)
 1556   1          {
 1557   2              a = 5;
 1558   2          }
 1559   1          else if(a >= 1000)
 1560   1          {
 1561   2              a = 4;
 1562   2          }
 1563   1          else if(a >= 100)
 1564   1          {
 1565   2              a = 3;
 1566   2          }
 1567   1          else if(a >= 10)
 1568   1          {
 1569   2              a = 2;
 1570   2          }
 1571   1          else
 1572   1          {
 1573   2              a = 1;
 1574   2          }
 1575   1          return a;
 1576   1      }
 1577          
 1578          //========================================================================
 1579          // å‡½æ•°: OLED_Mean2_fill_num(u8 a,u8 b,u8 (*dat)[16])
 1580          // æè¿°: å¿˜äº†ï¼Œæ€»ä¹‹æ˜¯å¡«å……ä¸€ä¸ª8*16çš„æ•°å­—åˆ°æ•°ç»„é‡Œé¢ï¼Œä¾›OLED_Mean2_fill_num2è£…æ•°æ®ç
             -š„
 1581          // å‚æ•°:                                                                                       
 1582          // è¿”å›:  
 1583          // ç‰ˆæœ¬: V1.0  2023.02.05
 1584          //========================================================================
 1585          void OLED_Mean2_fill_num(u8 a,u8 b,u8 (*dat)[16])
 1586          {
 1587   1          u8 i;
 1588   1          u8 j;
 1589   1          u8 c=0;
 1590   1          j = (a >> 1) << 1;
 1591   1          c = (a % 2) << 3;
 1592   1      
 1593   1          for(i = 0; i <8 ; i++)
 1594   1          {
 1595   2              UI_dat[j][i+c] = dat[b][i];
 1596   2      
 1597   2          }
 1598   1          j = j + 1;
 1599   1          for(i = 0; i <8 ; i++)
 1600   1          {
 1601   2              UI_dat[j][i+c] = dat[b][i+8];
 1602   2      
 1603   2          }
 1604   1      }
 1605          
 1606          //========================================================================
 1607          // å‡½æ•°: void OLED_Mean2_fill_num2(u16 a)
 1608          // æè¿°: å¡«å……äºŒçº§èœå•å­—ç¬¦ï¼Œæ ¹æ®dat00_maxæŸ¥è¯¢åˆ°çš„ç±»å‹è‡ªåŠ¨å¡«å……å¼€å…³ã€æ•°å­—ã€å•ä
             -½ã€å°æ•°ç‚¹ç­‰
 1609          // å‚æ•°:                                                                                       
 1610          // è¿”å›:  
 1611          // ç‰ˆæœ¬: V1.0  2023.02.05
 1612          //========================================================================
 1613          void OLED_Mean2_fill_num2(u16 a)
 1614          {
 1615   1          u8 i = 0;
 1616   1          u8 k;
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 26  

 1617   1          u16 dat = 0;
 1618   1          u8 xsd =0;
 1619   1          u8 fh = 0;
 1620   1          u8 adde = 7;
 1621   1          dat = dat00[a];
 1622   1          xsd = (u8)(dat00_max[a] >>14);
 1623   1          fh = (u8)((dat00_max[a] >>12) & 0x0003);
 1624   1          k =  (u8)((dat00_max[a] >>8) & 0x000F);
 1625   1          OLED_Mean2_fill(8,0);
 1626   1          if(fh > 0)
 1627   1          {
 1628   2              for(i = 0; i < fh; i++)
 1629   2              {
 1630   3                  OLED_Mean2_fill_num(adde,(u8)(k-i),F8x16_unit);
 1631   3                  adde--;
 1632   3              }
 1633   2          }
 1634   1          k = numlongGet(dat);
 1635   1          if(xsd)
 1636   1          {
 1637   2              if(k <= xsd)
 1638   2              {
 1639   3                  k = xsd + 2;
 1640   3              }
 1641   2              else
 1642   2              {
 1643   3                  k = k + 1;
 1644   3              }
 1645   2          }
 1646   1          for(i = 0; i < k; i++)
 1647   1          {
 1648   2              if(i == xsd && xsd != 0)
 1649   2              {
 1650   3                  OLED_Mean2_fill_num(adde,0x0B,F8x16);
 1651   3                  adde--;
 1652   3              }
 1653   2              else
 1654   2              {
 1655   3                  OLED_Mean2_fill_num(adde,(u8)(dat%10),F8x16);
 1656   3                  if(adde > 0) adde--;
 1657   3                  dat = dat/10;
 1658   3              }
 1659   2          }
 1660   1      }
 1661          
 1662          
 1663          
 1664          
 1665          //========================================================================
 1666          // å‡½æ•°: void shifen_dh_z(u8 t,u8 x,u8 yy,u16 y,u8  limit)
 1667          // æè¿°: æ˜¾ç¤ºæ»šåŠ¨çš„æ—¶åˆ†ç§’----å…¶ä¸­ä¸€è¡Œ
 1668          // å‚æ•°: t:æ¯ä¸ªå­—ç¬¦çš„ç¬¬å‡ è¡Œï¼ˆ4è¡Œä¸€ä¸ªå®Œæ•´å­—ç¬¦ï¼‰  x:xåæ ‡   yy:yåæ ‡    y:åç§»  li
             -mit:æœ€å¤§å€¼ï¼Œæ¯”å¦‚æ—¶çš„åä½ï¼Œæœ€å¤§å€¼å°±æ˜¯2ï¼Œè¶…è¿‡2è·³å›0
 1669          // è¿”å›:
 1670          // ç‰ˆæœ¬: V1.0 2023.02.05
 1671          //========================================================================
 1672          void shifen_dh_z(u8 t,u8 x,u8 yy,u16 y,u8  limit)//
 1673          {
 1674   1      //    u8 i;
 1675   1      //    OLED_Set_Pos(x,yy);
 1676   1      //    for(i=0; i<16; i++)
 1677   1      //    {
 1678   1      //        OLED_WrDat((F8x16d[(t+y/8) %  limit][i] >> (y % 8)) | (F8x16d[(t+1+y/8) %  limit][i] << 8-(y % 
             -8)));
 1679   1      //    }
 1680   1          u8 i;
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 27  

 1681   1          u8 *SPI_dat;
 1682   1          if(SPI_DMA_USE)
 1683   1          {
 1684   2              SPI_dat = SPI_DmaTxBuffer2;
 1685   2          }
 1686   1          else
 1687   1          {
 1688   2              SPI_dat = SPI_DmaTxBuffer;
 1689   2          }
 1690   1          for(i=0; i<16; i++)
 1691   1          {
 1692   2              SPI_dat[i] = (F8x16d[(t+y/8) %  limit][i] >> (y % 8)) | (F8x16d[(t+1+y/8) %  limit][i] << 8-(y % 
             -8));
 1693   2          }
 1694   1          OLED_Set_Pos(x,yy);
 1695   1          SPI_DMA_switch();
 1696   1          SPI_DMA_TX((u8)(i-1));
 1697   1      }
 1698          
 1699          
 1700          
 1701          
 1702          
 1703          //========================================================================
 1704          // å‡½æ•°: void shifen_dh(u8 x,u8 yy,u16 y,u8  limit)
 1705          // æè¿°: æ˜¾ç¤ºæ»šåŠ¨çš„æ—¶åˆ†ç§’
 1706          // å‚æ•°: x:xåæ ‡   yy:    y:yåæ ‡ limit:å¼ºåˆ¶æ˜¾ç¤ºï¼Œç”¨äºåˆå§‹åŒ–
 1707          // è¿”å›:
 1708          // ç‰ˆæœ¬: V1.0 2023.02.05
 1709          //========================================================================
 1710          void shifen_dh(u8 x,u8 yy,u16 y,u8  limit)
 1711          {
 1712   1          unsigned char i;
 1713   1          for(i=0; i<4; i++)
 1714   1          {
 1715   2              shifen_dh_z(i,x,(u8)(yy+i),y, limit);
 1716   2      
 1717   2          }
 1718   1      }
 1719          
 1720          
 1721          
 1722          //========================================================================
 1723          // å‡½æ•°: void IU_Battery_Icon_S_1(u8 x,u8 y)
 1724          // æè¿°: TVæ¨¡å¼ç”µæ± ç•Œé¢æ˜¾ç¤º---å¤§ç”µæ± ä¸‹é¢ç”µé‡çš„æ˜¾ç¤º
 1725          // å‚æ•°: x:xåæ ‡ y:yåæ ‡
 1726          // è¿”å›:
 1727          // ç‰ˆæœ¬: V1.0 2023.02.05
 1728          //========================================================================
 1729          void IU_Battery_Icon_S_1(u8 x,u8 y)
 1730          {
 1731   1          u8 j,k;
 1732   1      
 1733   1          k = (u8)(dat00[0x00E5] /1000);
 1734   1          if(k!=0)
 1735   1          {
 1736   2              ZF_8X8((u8)(x+24),y,k);
 1737   2          }
 1738   1          else
 1739   1          {
 1740   2              ZF_8X8((u8)(x+24),y,0x0A);
 1741   2          }
 1742   1      
 1743   1          j = (u8)((dat00[0x00E5] % 1000)/100);
 1744   1          if(k==0 && j==0)
 1745   1          {
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 28  

 1746   2              ZF_8X8((u8)(x+32),y,0x0A);
 1747   2          }
 1748   1          else
 1749   1          {
 1750   2              ZF_8X8((u8)(x+32),y,j);
 1751   2          }
 1752   1          ZF_8X8((u8)(x+40),y,(u8)((dat00[0x00E5] % 100)/10));
 1753   1      
 1754   1      
 1755   1      
 1756   1      
 1757   1      
 1758   1      }
 1759          
 1760          
 1761          
 1762          //========================================================================
 1763          // å‡½æ•°: IU_Battery_Icon_S(u8 x,u8 y,u8 p)
 1764          // æè¿°: å³ä¸Šè§’ç”µæ± UIæ˜¾ç¤º
 1765          // å‚æ•°: x:xåæ ‡ y:yåæ ‡ p:å¼ºåˆ¶æ˜¾ç¤ºï¼Œç”¨äºåˆå§‹åŒ–
 1766          // è¿”å›:
 1767          // ç‰ˆæœ¬: V1.0 2023.02.05
 1768          //========================================================================
 1769          void IU_Battery_Icon_S(u8 x,u8 y,u8 p)
 1770          {
 1771   1          u16 a = 0;
 1772   1          u8 j = 0;
 1773   1          u8 i;
 1774   1          u8 k=0;
 1775   1      
 1776   1          if((dat00[0x00E5] != Battery_PE_Low) || p)
 1777   1          {
 1778   2              a =  dat00[0x00E5]/83;
 1779   2              OLED_Set_Pos((u8)(x+8),y);
 1780   2      
 1781   2              for(i=0; i<16; i++)
 1782   2              {
 1783   3                  if(i == 0)
 1784   3                  {
 1785   4                      OLED_WrDat(0xFf);
 1786   4                  }
 1787   3                  else if(i == 1)
 1788   3                  {
 1789   4                      OLED_WrDat(0x81);
 1790   4                  }
 1791   3                  else if(i <= 12)
 1792   3                  {
 1793   4                      if((a + 1) >= i)
 1794   4                      {
 1795   5                          OLED_WrDat(0xBD);
 1796   5                      }
 1797   4                      else
 1798   4                      {
 1799   5                          OLED_WrDat(0x81);
 1800   5                      }
 1801   4                  }
 1802   3                  else if(i <= 13)
 1803   3                  {
 1804   4                      if(a == 12)
 1805   4                      {
 1806   5                          OLED_WrDat(0x99);
 1807   5                      }
 1808   4                      else
 1809   4                      {
 1810   5                          OLED_WrDat(0x81);
 1811   5                      }
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 29  

 1812   4                  }
 1813   3                  else if(i <= 14)
 1814   3                  {
 1815   4                      OLED_WrDat(0xC3);
 1816   4                  }
 1817   3                  else if(i <= 15)
 1818   3                  {
 1819   4                      OLED_WrDat(0x3C);
 1820   4                  }
 1821   3              }
 1822   2      
 1823   2              IU_Battery_Icon_S_1(x,y);
 1824   2              if(dat00[0x00E1])
 1825   2              {
 1826   3                  ZF_8X8(x,y,0x0B);
 1827   3              }
 1828   2              else
 1829   2              {
 1830   3                  ZF_8X8(x,y,0x0A);
 1831   3              }
 1832   2              Battery_PE_Low = dat00[0x00E5];
 1833   2          }
 1834   1      }
 1835          
 1836          
 1837          //*************************ç”µæ± ç•Œé¢UI********************
 1838          
 1839          
 1840          
 1841          //========================================================================
 1842          // å‡½æ•°: void IU_Battery_cheek()
 1843          // æè¿°: TVæ¨¡å¼ç”µæ± ç•Œé¢æ˜¾ç¤º---ç”»å‡ºå¤§ç”µæ± å¤–å£³
 1844          // å‚æ•°: 
 1845          // è¿”å›:
 1846          // ç‰ˆæœ¬: V1.0 2023.02.05
 1847          //========================================================================
 1848          void IU_Battery_cheek()
 1849          {
 1850   1          u8 i =0;
 1851   1          for(i=2; i<6; i++)
 1852   1          {
 1853   2              ZF_8X8(120,i,16);
 1854   2          }
 1855   1      
 1856   1          for(i=2; i<6; i++)
 1857   1          {
 1858   2              ZF_8X8(96,i,16);
 1859   2          }
 1860   1      
 1861   1          OLED_Set_Pos(104,1);
 1862   1          for(i=0; i<2; i++)
 1863   1          {
 1864   2              OLED_WrDat(0x3c);
 1865   2          }
 1866   1          for(i=0; i<12; i++)
 1867   1          {
 1868   2              OLED_WrDat(0x3f);
 1869   2          }
 1870   1          for(i=0; i<2; i++)
 1871   1          {
 1872   2              OLED_WrDat(0x3c);
 1873   2          }
 1874   1      
 1875   1          OLED_Set_Pos(104,6);
 1876   1          for(i=0; i<16; i++)
 1877   1          {
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 30  

 1878   2              OLED_WrDat(0x3c);
 1879   2          }
 1880   1          ZF_8X8(96,1,18);
 1881   1          ZF_8X8(120,1,19);
 1882   1          ZF_8X8(96,6,21);
 1883   1          ZF_8X8(120,6,20);
 1884   1      
 1885   1      
 1886   1      
 1887   1          ZF_8X16(80,5,25);
 1888   1          ZF_8X16(88,5,26);
 1889   1      
 1890   1          ZF_8X16(8,5,11);
 1891   1          ZF_8X16(28,5,27);
 1892   1      
 1893   1      }
 1894          
 1895          
 1896          
 1897          
 1898          //========================================================================
 1899          // å‡½æ•°: void IU_16x8_Fill(u8 x,u8 y,u8 t)
 1900          // æè¿°: x:xåæ ‡   y:yåæ ‡  tï¼šéœ€è¦å†™å…¥çš„æ•°æ®
 1901          // å‚æ•°: 
 1902          // è¿”å›:
 1903          // ç‰ˆæœ¬: V1.0 2023.02.05
 1904          //========================================================================
 1905          void IU_16x8_Fill(u8 x,u8 y,u8 t)
 1906          {
 1907   1          u8 i;
 1908   1          OLED_Set_Pos(x,y);
 1909   1          for(i=0; i<16; i++)
 1910   1          {
 1911   2              OLED_WrDat(t);
 1912   2          }
 1913   1      }
 1914          
 1915          
 1916          //========================================================================
 1917          // å‡½æ•°: IU_Battery_cheek_renovate_count(u16 a,u8 x,u8 y,u8 t)
 1918          // æè¿°: TVæ¨¡å¼ç”µæ± ç•Œé¢æ˜¾ç¤º---ç”»å‡ºå¤§ç”µæ± é‡Œé¢çš„ä¸€å±‚çš„ç”µé‡
 1919          // å‚æ•°: aï¼šç”µé‡  x:xåæ ‡   y:yåæ ‡  tï¼šå±‚æ•°
 1920          // è¿”å›:
 1921          // ç‰ˆæœ¬: V1.0 2023.02.05
 1922          //========================================================================
 1923          void IU_Battery_cheek_renovate_count(u16 a,u8 x,u8 y,u8 t)
 1924          {
 1925   1          u8 b,p;
 1926   1          p = t + 8;
 1927   1          if(a>=p)
 1928   1          {
 1929   2              b = 0xff;
 1930   2          }
 1931   1          else if( a > t && a <= p)
 1932   1          {
 1933   2              b = 0xff;
 1934   2              b = b << (p-a);
 1935   2          }
 1936   1          else
 1937   1          {
 1938   2              b = 0;
 1939   2          }
 1940   1          IU_16x8_Fill(x,y,b);
 1941   1      
 1942   1      
 1943   1      }
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 31  

 1944          
 1945          //========================================================================
 1946          // å‡½æ•°: IU_Battery_cheek_renovate()
 1947          // æè¿°: TVæ¨¡å¼ç”µæ± ç•Œé¢æ˜¾ç¤º---å…¶ä»–éƒ¨åˆ†çš„åˆ·æ–°
 1948          // å‚æ•°: 
 1949          // è¿”å›:
 1950          // ç‰ˆæœ¬: V1.0 2023.02.05
 1951          //========================================================================
 1952          void IU_Battery_cheek_renovate()
 1953          {
 1954   1          u16 a = 0;
 1955   1          u8 b = 0;
 1956   1          u8 i ;
 1957   1          a =  (u8)((u32)dat00[0x00E5]*100/3125);
 1958   1      
 1959   1          //miao((u8)dat00[0x00E2]);
 1960   1      
 1961   1          if(dat00[0x00E2])
 1962   1          {
 1963   2              IU_Battery_cheek_renovate_count(a,104,2,24);
 1964   2              IU_Battery_cheek_renovate_count(a,104,3,16);
 1965   2              IU_Battery_cheek_renovate_count(a,104,4,8);
 1966   2              IU_Battery_cheek_renovate_count(a,104,5,0);
 1967   2      
 1968   2          }
 1969   1          else
 1970   1          {
 1971   2              IU_16x8_Fill(104,2,0);
 1972   2              IU_16x8_Fill(104,5,0);
 1973   2              OLED_Set_Pos(104,3);
 1974   2              ZF_8X8(104,3,22);
 1975   2              ZF_8X8(112,3,23);
 1976   2              ZF_8X8(104,4,23);
 1977   2              ZF_8X8(112,4,22);
 1978   2          }
 1979   1      
 1980   1          if(dat00[0x00E1])
 1981   1          {
 1982   2      
 1983   2              if((u8)(Time_New[0] % 6) == 0)
 1984   2              {
 1985   3                  ZF_8X16(72,3,10);
 1986   3                  ZF_8X16(80,3,10);
 1987   3              }
 1988   2              ZF_8X16((u8)(24 + (Time_New[0] % 6) * 8),3,10);
 1989   2              ZF_8X16((u8)(32 + (Time_New[0] % 6) * 8),3,23);
 1990   2              ZF_8X16((u8)(40 + (Time_New[0] % 6) * 8),3,24);
 1991   2          }
 1992   1          else
 1993   1          {
 1994   2              if(dat00_low[0x00E1] != dat00[0x00E1])
 1995   2              {
 1996   3                  OLED_Set_Pos(24,3);
 1997   3                  for(i = 0; i<56; i++)
 1998   3                  {
 1999   4                      OLED_WrDat(0x00);
 2000   4                  }
 2001   3                  OLED_Set_Pos(24,4);
 2002   3                  for(i = 0; i<56; i++)
 2003   3                  {
 2004   4                      OLED_WrDat(0x00);
 2005   4                  }
 2006   3              }
 2007   2          }
 2008   1      
 2009   1      
C251 COMPILER V5.60.0,  OLED                                                               25/04/24  00:23:36  PAGE 32  

 2010   1          if(dat00[0x00E4]>=100)
 2011   1          {
 2012   2              ZF_8X16(54,5,(u8)((dat00[0x00E4]%1000)/100));
 2013   2          }
 2014   1          else
 2015   1          {
 2016   2              ZF_8X16(54,5,10);
 2017   2          }
 2018   1      
 2019   1          if(dat00[0x00E4]>=10)
 2020   1          {
 2021   2              ZF_8X16(62,5,(u8)((dat00[0x00E4]%100)/10));
 2022   2          }
 2023   1          else
 2024   1          {
 2025   2              ZF_8X16(62,5,10);
 2026   2          }
 2027   1          ZF_8X16(70,5,(u8)(dat00[0x00E4]%10));
 2028   1      
 2029   1      
 2030   1          ZF_8X16(0,5,(u8)((dat00[0x00E3]/1000)));
 2031   1          ZF_8X16(12,5,(u8)((dat00[0x00E3]%1000)/100));
 2032   1          ZF_8X16(20,5,(u8)((dat00[0x00E3]%100)/10));
 2033   1      
 2034   1          IU_Battery_Icon_S_1(76,7);
 2035   1      }
 2036          
 2037          void OLED_16_16V2a()
 2038          {
 2039   1          u8 i=0;
 2040   1          delay_ms(200);
 2041   1          delay_ms(200);;
 2042   1          delay_ms(200);
 2043   1          delay_ms(200);
 2044   1          delay_ms(200);
 2045   1          delay_ms(200);
 2046   1          delay_ms(200);
 2047   1          delay_ms(200);
 2048   1      
 2049   1      
 2050   1      }
 2051          
 2052          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =     23410     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       768     ------
  xdata-const size     =    ------     ------
  edata size           =         2         59
  bit size             =    ------          4
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        10     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
