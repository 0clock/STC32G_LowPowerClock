C251 COMPILER V5.60.0,  DATA                                                               25/04/24  00:23:35  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE DATA
OBJECT MODULE PLACED IN DATA.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE DATA.c XSMALL OPTIMIZE(9,SPEED) BROWSE DEBUG TABS(2) 

stmt  level    source

    1          #include "DATA.h"
    2          #include "UI.h"
    3          #include "OLED.h"
    4          #include "time.h"
    5          #include "UART1.h"
    6          #include "INS5699S.h"
    7          #include "SleepMode.h"
    8          
    9          
   10          /****************************** 控制寄存器组 ***********************************/
   11          volatile u16 dat00[System_data_num]=
   12          {
   13          //0程序系统参数
   14              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   15          
   16          //1UI光标寄存器组
   17              0,0,0,0,0x8000,0x8000,0,0x000A,0x000A,0,0,0,0,0,0,0,
   18          
   19          //2标准模式寄存器组
   20              6,0,40,10,10,2,1,0,0,0,0,0,0,0,0,0,
   21          
   22          //3休眠模式寄存器组
   23              7,5,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
   24          
   25          //4环境信息寄存器组
   26              0x0007,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   27          
   28          //5亮度设置寄存器组
   29              0x0008,0x00FF,0,0,0x0008,0x0005,0x0001,0x000f,0,0,0,0,0,0,0,0,
   30          
   31          //6指南针寄存器组
   32              0,0,0,0,0,0,0,0,0,1,6,0,0,0,0,0,
   33          
   34          //7水平尺寄存器组
   35              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   36          
   37          //8时间设置寄存器组
   38              8,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
   39          
   40          //9闹钟寄存器组
   41              9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   42          
   43          //10增量闹钟寄存器组
   44              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   45          
   46          //11秒表寄存器组
   47              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   48          
   49          //12声音设置寄存器组
   50              0x0003,0,20,1,0,0,0,0,0,0,0,0,0,0,0,0,
   51          
   52          //13手电筒设置寄存器组
   53              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   54          
   55          //14电源管理寄存器组
   56              0x0006,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   57          
   58          //15系统设置寄存器组
   59              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
C251 COMPILER V5.60.0,  DATA                                                               25/04/24  00:23:35  PAGE 2   

   60          
   61          //16系统信息寄存器组
   62              0x000C,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   63          
   64          //17工厂模式寄存器组
   65              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   66          
   67          };
   68          
   69          
   70          
   71          volatile u16 dat00_low[System_data_num]=
   72          {
   73          //0程序系统参数
   74              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   75          
   76          //1UI光标寄存器组
   77              0,0,0,0,0x8000,0x8000,0,0x000A,0x000A,0,0,0,0,0,0,0,
   78          
   79          //2标准模式寄存器组
   80              6,0,40,10,10,2,1,0,0,0,0,0,0,0,0,0,
   81          
   82          //3休眠模式寄存器组
   83              7,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   84          
   85          //4环境信息寄存器组
   86              0x0007,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   87          
   88          //5亮度设置寄存器组
   89              0x0008,0x00FF,0,0,0x0008,0x0005,0x0001,0x000f,0,0,0,0,0,0,0,0,
   90          
   91          //6指南针寄存器组
   92              0,0,0,0,0,0,0,0,0,1,6,0,0,0,0,0,
   93          
   94          //7水平尺寄存器组
   95              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   96          
   97          //8时间设置寄存器组
   98              8,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
   99          
  100          //9闹钟寄存器组
  101              9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  102          
  103          //10增量闹钟寄存器组
  104              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  105          
  106          //11秒表寄存器组
  107              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  108          
  109          //12声音设置寄存器组
  110              0x0003,0,20,1,0,0,0,0,0,0,0,0,0,0,0,0,
  111          
  112          //13手电筒设置寄存器组
  113              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  114          
  115          //14电源管理寄存器组
  116              0x0006,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  117          
  118          //15系统设置寄存器组
  119              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  120          
  121          //16系统信息寄存器组
  122              0x000C,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  123          
  124          //17工厂模式寄存器组
  125              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
C251 COMPILER V5.60.0,  DATA                                                               25/04/24  00:23:35  PAGE 3   

  126          
  127          };
  128          
  129          volatile u8 xdata dat00_flag[System_data_num]= {0};
  130          
  131          volatile u16 xdata dat00_max[System_data_num]=
  132          {
  133          //0程序系统参数
  134              0,0,0,0,0,0,0,0,60,0,0,0,0,0,0,0,
  135          
  136          //1UI光标寄存器组
  137              0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  138          
  139          //2标准模式寄存器组
  140              0XFF,0x1001,0x110C,0x1103,0x1103,0x1103,0xFF,0,0,0,0,0,0,0,0,0,
  141          
  142          //3休眠模式寄存器组
  143              0XFF,0x110C,0x1103,0x1103,0x1103,0x1001,0x1001,0xFF,0,0,0,0,0,0,0,0,
  144          
  145          //4环境信息寄存器组
  146              0XFF,0xA38D,0x948D,0x378D,0x2C8D,0x2C8D,0x2C8D,0x2C8D,0,0,0,0,0,0,0,0,
  147          
  148          //5亮度设置寄存器组
  149              0XFF,0x0A,0x0B,0x1001,0x001C,0x001C,0x001C,0x001C,0x0B,0,0,0,0,0,0,0,
  150          
  151          //6指南针寄存器组
  152              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  153          
  154          //7水平尺寄存器组
  155              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  156          
  157          //8时间设置寄存器组
  158              0xff,0x00ff,0x000F,0x000F,0x000E,0x0010,0x0013,0x0011,0x0012,0x1001,0x1001,0x1001,0x1103,0,0,0,
  159          
  160          //9闹钟寄存器组
  161              0xff,0x000F,0x000F,0x000E,0x0018,0x0017,0x1001,0x1001,0x110C,0x1001,0,0,0,0,0,0,
  162          
  163          //10增量闹钟寄存器组
  164              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  165          
  166          //11秒表寄存器组
  167              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  168          
  169          //12声音设置寄存器组
  170              0XFF,0x1001,0x210C,0x1001,0,0,0,0,0,0,0,0,0,0,0,0,
  171          
  172          //13手电筒设置寄存器组
  173              0xFF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  174          
  175          //14电源管理寄存器组
  176              0xFF,0x0081,0x0081,0xDA8D,0x298D,0x548D,0x1001,0,0,0,0,0,0,0,0,0,
  177          
  178          //15系统设置寄存器组
  179              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  180          
  181          //16系统信息寄存器组
  182              0XFF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  183          
  184          //17工厂模式寄存器组
  185              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  186          
  187          };
  188          //最大值寄存器（低6位）：
  189          //0:0~0xffff
  190          //1:0~1
  191          //2:0~10
C251 COMPILER V5.60.0,  DATA                                                               25/04/24  00:23:35  PAGE 4   

  192          //3:0~100
  193          //4:0~1000
  194          //5:0~10000
  195          //6:0~0xff
  196          //7:0~0x80
  197          //8:0~0x7F
  198          //9:0~UI_main_branchnum 主菜单分支数-1
  199          //10:1~0xFF
  200          //11:0~3
  201          //12:1~100
  202          //13:0~0xFFFF
  203          //14:0~23
  204          //15:0~59
  205          //16:0~6
  206          //17:1~12
  207          
  208          //(18)19:0~99
  209          //(19)18:1~31
  210          
  211          //20:1~30
  212          //21:1~29
  213          //22:1~28
  214          
  215          //23:0~12
  216          //24:0~31
  217          //25:0~30
  218          //26:0~29
  219          //27:0~28
  220          //28:1~15
  221          
  222          
  223          
  224          //7bit=1:不可修改
  225          //6bit=1:不显示数值
  226          
  227          //最大值寄存器（高8位）：
  228          
  229          //bit15 + bit14 2位：小数点位数
  230          //bit13 + bit12 2位：单位符号个数
  231          //bit11 ~ bit8 4位：单位符号开始地址
  232          
  233          
  234          
  235          
  236          
  237          /****************************** UI图形缓冲存器组 ***********************************/
  238          u8  UI_dat[8][16] = {0};
  239          
  240          u8  UI_TX[3][64] = {0};
  241          
  242          
  243          
  244          /****************************** 睡眠寄存器组 ***********************************/
  245          u16  Sleep_Queue[Sleep_queue_num]= {0};
  246          u16  Sleep_Queue_count = 0;
  247          u16  Sleep_Queue_count_target = 0;
  248          
  249          
  250          
  251          u16  Sleep_Queue_task[Sleep_queue_num]= {0};
  252          
  253          
  254          
  255          /****************************** 时间寄存器组 ***********************************/
  256          //年 月 日 周 时 分 秒
  257          u8 Time_New[7] = {0,0,0,0,0,0,0};
C251 COMPILER V5.60.0,  DATA                                                               25/04/24  00:23:35  PAGE 5   

  258          u8 Time_Low[7] = {0,0,0,0,0,0,0};
  259          //u8 xdata Time_int[7] = {0x50,0x30,0x09,0x01,0x27,0x02,0x23};
  260          u8 xdata Time_int[7] = {0x30,0x59,0x23,0x40,0x31,0x01,0x23};
  261          //u8 xdata Time_int[7] = {0x01,0x00,0x00,0x80,0x01,0x02,0x23};
  262          
  263          
  264          
  265          
  266          
  267          //========================================================================
  268          // 函数: void Array_Initialization_8(u8 *array_name,u16 array_num)
  269          // 描述: 初始化一个数组
  270          // 参数: 
  271          // 返回: 
  272          // 版本: V1.0 2023.02.05
  273          //========================================================================
  274          void Array_Initialization_8(u8 *array_name,u16 array_num)
  275          {
  276   1          u16 i=0;
  277   1          for(i=0; i<array_num; i++)
  278   1          {
  279   2              array_name[i]=0;
  280   2          }
  281   1      }
  282          //========================================================================
  283          // 函数: void Array_Initialization_16(u16 *array_name,u16 array_num)
  284          // 描述: 初始化一个数组
  285          // 参数: 
  286          // 返回: 
  287          // 版本: V1.0 2023.02.05
  288          //========================================================================
  289          void Array_Initialization_16(u16 *array_name,u16 array_num)
  290          {
  291   1          u16 i=0;
  292   1          for(i=0; i<array_num; i++)
  293   1          {
  294   2              array_name[i]=0;
  295   2          }
  296   1      }
  297          
  298          //========================================================================
  299          // 函数: void Array_Initialization_()
  300          // 描述: 初始化数组
  301          // 参数: 
  302          // 返回: 
  303          // 版本: V1.0 2023.02.05
  304          //========================================================================
  305          void Array_Initialization_()
  306          {
  307   1          Array_Initialization_16(Sleep_Queue,Sleep_queue_num);
  308   1          Array_Initialization_16(Sleep_Queue_task,Sleep_queue_num);
  309   1          Array_Initialization_8(Time_Low,7);
  310   1          Array_Initialization_8(Time_New,7);
  311   1          Array_Initialization_8(dat00_flag,System_data_num);
  312   1      }
  313          
  314          
  315          
  316          
  317          
  318          
  319          //========================================================================
  320          // 函数: void array_fill(u16 *array_name,u16 array_num,u16 array_dat,u16 w)
  321          // 描述: 从数组的[array_num]开始装填array_dat，装填w个
  322          // 参数: 
  323          // 返回: 
C251 COMPILER V5.60.0,  DATA                                                               25/04/24  00:23:35  PAGE 6   

  324          // 版本: V1.0 2023.02.05
  325          //========================================================================
  326          void array_fill(u16 *array_name,u16 array_num,u16 array_dat,u16 w)
  327          {
  328   1          u16 j = 0;
  329   1          array_num = array_num + w;
  330   1          for(j=w; j<array_num; j++)
  331   1          {
  332   2              array_name[j]=array_dat;
  333   2          }
  334   1      }
  335          //========================================================================
  336          // 函数: u16 RFF()
  337          // 描述: 检测一个数组里面不为0的部分长到哪里
  338          // 参数: 
  339          // 返回: 数组有效长度
  340          // 版本: V1.0 2023.02.05
  341          //========================================================================
  342          u16 RFF()
  343          {
  344   1          u16 i = 0;
  345   1          u16 b = 0;
  346   1          u16 a = 0;
  347   1          for(i = 7; i<Sleep_queue_num; i = i + 8)
  348   1          {
  349   2              if(Sleep_Queue[i] == 0)
  350   2              {
  351   3                  b = i;
  352   3                  i = 200;
  353   3              }
  354   2          }
  355   1      
  356   1          for(i = b-7; i<=b; i++)
  357   1          {
  358   2              if(Sleep_Queue[i] == 0)
  359   2              {
  360   3                  a = i;
  361   3                  i = 200;
  362   3              }
  363   2          }
  364   1          return a;
  365   1      
  366   1      }
  367          
  368          //========================================================================
  369          // 函数: void SleepQueue_MoveLeft(u16 p)
  370          // 描述: 睡眠任务队列和睡眠任务时间队列左移p位(使用快速算法)
  371          // 参数: 
  372          // 返回: 
  373          // 版本: V1.0 2023.02.05
  374          //========================================================================
  375          void SleepQueue_MoveLeft(u16 p)
  376          {
  377   1          u16 j = 0;
  378   1          u16 h =0;
  379   1          h = RFF();
  380   1          for(j=0; j<h; j++)
  381   1          {
  382   2              Sleep_Queue[j]=Sleep_Queue[j+p];
  383   2              Sleep_Queue_task[j]=Sleep_Queue_task[j+p];
  384   2          }
  385   1          Sleep_Queue[h]=0;
  386   1          Sleep_Queue_task[h]=0;
  387   1      }
  388          
  389          
C251 COMPILER V5.60.0,  DATA                                                               25/04/24  00:23:35  PAGE 7   

  390          
  391          //========================================================================
  392          // 函数: void SleepQueue_MoveLeft2
  393          // 描述: 睡眠任务队列和睡眠任务时间队列左移一位
  394          // 参数: 
  395          // 返回: 
  396          // 版本: V1.0 2023.02.05
  397          //========================================================================
  398          void SleepQueue_MoveLeft2()
  399          {
  400   1          u16 j = 0;
  401   1          u16 h =0;
  402   1          h = Sleep_queue_num -2;
  403   1          for(j=0; j<h; j++)
  404   1          {
  405   2              Sleep_Queue[j]=Sleep_Queue[j+1];
  406   2              Sleep_Queue_task[j]=Sleep_Queue_task[j+1];
  407   2          }
  408   1          Sleep_Queue[h]=0;
  409   1          Sleep_Queue_task[h]=0;
  410   1      }
  411          
  412          
  413          
  414          
  415          
  416          //========================================================================
  417          // 函数: void SleepQueue_behindW(u16 time,u16 num)
  418          // 描述: 在队尾插入时间time和任务num
  419          // 参数: 
  420          // 返回: 
  421          // 版本: V1.0 2023.02.05
  422          //========================================================================
  423          void SleepQueue_behindW(u16 time,u16 num)
  424          {
  425   1          u16 j = 0;
  426   1          j = RFF();
  427   1      
  428   1          Sleep_Queue[j]=time;
  429   1          Sleep_Queue_task[j]=num;
  430   1      
  431   1      }
  432          
  433          
  434          //========================================================================
  435          // 函数: void SleepQueue_aheadW1(u16 time,u16 num,u16 f)
  436          // 描述: 在队列第f个插入时间time和任务num
  437          // 参数: 
  438          // 返回: 
  439          // 版本: V1.0 2023.02.05
  440          //========================================================================
  441          void SleepQueue_aheadW1(u16 time,u16 num,u16 f)
  442          {
  443   1          u16 i = 0;
  444   1          u16 k = 0;
  445   1          u16 j = 0;
  446   1          for(i=f; i<Sleep_queue_num; i++)
  447   1          {
  448   2              j = j + Sleep_Queue[i];
  449   2      
  450   2      
  451   2              if(Sleep_Queue[i] != 0 && time < j)
  452   2              {
  453   3                  for(k= RFF(); k>i; k--)
  454   3                  {
  455   4                      Sleep_Queue[k]=Sleep_Queue[k-1];
C251 COMPILER V5.60.0,  DATA                                                               25/04/24  00:23:35  PAGE 8   

  456   4                      Sleep_Queue_task[k]  = Sleep_Queue_task[k-1];
  457   4                  }
  458   3                  Sleep_Queue[i] = time - ( j - Sleep_Queue[i+1]);
  459   3                  Sleep_Queue_task[i]  = num;
  460   3                  Sleep_Queue[i+1] = Sleep_Queue[i+1] - Sleep_Queue[i];
  461   3                  i  = 200;
  462   3              }
  463   2              else if(Sleep_Queue[i] != 0 && time == j)
  464   2              {
  465   3                  Sleep_Queue_task[i]  |= num;
  466   3                  i  = 200;
  467   3              }
  468   2              else if(Sleep_Queue[i] == 0)
  469   2              {
  470   3                  Sleep_Queue[i] = time - j;
  471   3                  Sleep_Queue_task[i]  = num;
  472   3                  i  = 200;
  473   3              }
  474   2          }
  475   1      }
  476          
  477          //========================================================================
  478          // 函数: void fast_SleepQueue_aheadW1(u16 dat,u16 task,u8 num)
  479          // 描述: 快速插入算法 在队首快速插入num 个时间dat和任务task
  480          // 参数: 
  481          // 返回: 
  482          // 版本: V1.0 2023.02.05
  483          //========================================================================
  484          void fast_SleepQueue_aheadW1(u16 dat,u16 task,u8 num)
  485          {
  486   1          u16 a =0;
  487   1          u16 i =0;
  488   1          u16 j =0;
  489   1          a = RFF();//获得数组有数值的长度
  490   1          if(a == 0)
  491   1          {
  492   2              array_fill(Sleep_Queue,num,dat,0);
  493   2              array_fill(Sleep_Queue_task,num,task,0);
  494   2          }
  495   1          else
  496   1          {
  497   2              array_fill(Sleep_Queue,num,dat,a);
  498   2              array_fill(Sleep_Queue_task,num,task,a);
  499   2              for(i = 0; i < a; i++) //共处理 n 个数据
  500   2              {
  501   3                  j = j + Sleep_Queue[i];
  502   3                  SleepQueue_aheadW1(j,Sleep_Queue_task[i],a);
  503   3              }
  504   2          }
  505   1          if(a) SleepQueue_MoveLeft(a);
  506   1      }
  507          
  508          
  509          
  510          //========================================================================
  511          // 函数: u16 data_GetMax(u16 dat)
  512          // 描述: 获取光标指向的数据的最大值
  513          // 参数: 
  514          // 返回: 光标指向的数据的最大值
  515          // 版本: V1.0 2023.02.05
  516          //========================================================================
  517          u16 data_GetMax(u16 dat)
  518          {
  519   1          u16 k =0;
  520   1          dat = dat00_max[dat];
  521   1          dat &= 0x003F;
C251 COMPILER V5.60.0,  DATA                                                               25/04/24  00:23:35  PAGE 9   

  522   1          switch (dat)
  523   1          {
  524   2          case 0x00 :
  525   2              k=0xffff;
  526   2              break;
  527   2          case 0x01 :
  528   2              k=1;
  529   2              break;
  530   2          case 0x02 :
  531   2              k=10;
  532   2              break;
  533   2          case 0x03 :
  534   2              k=100;
  535   2              break;
  536   2          case 0x04 :
  537   2              k=1000;
  538   2              break;
  539   2          case 0x05 :
  540   2              k=10000;
  541   2              break;
  542   2          case 0x06 :
  543   2              k=0xff;
  544   2              break;
  545   2          case 0x07 :
  546   2              k=0x80;
  547   2              break;
  548   2          case 0x08 :
  549   2              k=0x7f;
  550   2              break;
  551   2          case 0x09 :
  552   2              k=UI_main_branchnum;
  553   2              break;
  554   2          case 0x0A :
  555   2              k=0xff;
  556   2              break;
  557   2          case 0x0B :
  558   2              k=0x03;
  559   2              break;
  560   2          case 0x0C :
  561   2              k=100;
  562   2              break;
  563   2          case 0x0D :
  564   2              k=0xFFFF;
  565   2              break;
  566   2          case 0x0E :
  567   2              k=0x0017;
  568   2              break;
  569   2          case 0x0F :
  570   2              k=0x003B;
  571   2              break;
  572   2          case 0x10 :
  573   2              k=0x0006;
  574   2              break;
  575   2          case 0x11 :
  576   2              k=12;
  577   2              break;
  578   2          case 0x12 : k=99; break;
  579   2          case 0x13 : k=31;  break;
  580   2          case 0x14 : k=30; break;
  581   2          case 0x15 : k=29;  break;
  582   2          case 0x16 : k=28;  break;
  583   2          case 0x17 : k=12;  break;
  584   2          case 0x18 : k=31;  break;   
  585   2          case 0x19 : k=30;  break;   
  586   2          case 0x1A : k=29;  break;   
  587   2          case 0x1B : k=28;  break; 
C251 COMPILER V5.60.0,  DATA                                                               25/04/24  00:23:35  PAGE 10  

  588   2          case 0x1C : k=15;  break; 
  589   2      
  590   2      
  591   2          
  592   2          case 0xFF : k=0;   break;
  593   2          default:    k=0;   break;
  594   2      //**********************************************
  595   2          }
  596   1          return k;
  597   1      }
  598          
  599          //========================================================================
  600          // 函数: u16 data_GetMin(u16 dat)
  601          // 描述: 获取光标指向的数据的最小值
  602          // 参数: 
  603          // 返回: 光标指向的数据的最小值
  604          // 版本: V1.0 2023.02.05
  605          //========================================================================
  606          u16 data_GetMin(u16 dat)
  607          {
  608   1          u16 k =0;
  609   1          dat = dat00_max[dat];
  610   1          dat &= 0x003F;
  611   1      
  612   1          if(dat == 0x0A || dat == 0x0C || dat == 0x11 || dat == 0x13 || dat == 0x14 || dat == 0x15 || dat == 0
             -x16 || dat == 0x1C  )
  613   1          {
  614   2              k=1;
  615   2          }
  616   1          return k;
  617   1      }
  618          
  619          
  620          
  621          //========================================================================
  622          // 函数: void data00_Change(u16 address,u16 add)
  623          // 描述: 数据+1或者-1溢出会自动变成最大或者最小
  624          // 参数: 
  625          // 返回: 
  626          // 版本: V1.0 2023.02.05
  627          //========================================================================
  628          void data00_Change(u16 address,u16 add)
  629          {
  630   1          if(add)
  631   1          {
  632   2              if(dat00[address] >= data_GetMax(address))
  633   2              {
  634   3                  dat00[address] = data_GetMin(address);
  635   3              }
  636   2              else
  637   2              {
  638   3                  dat00[address]++;
  639   3              }
  640   2          }
  641   1          else
  642   1          {
  643   2              if(dat00[address] <= data_GetMin(address))
  644   2              {
  645   3                  dat00[address] = data_GetMax(address);
  646   3              }
  647   2              else
  648   2              {
  649   3                  dat00[address]--;
  650   3              }
  651   2      
  652   2          }
C251 COMPILER V5.60.0,  DATA                                                               25/04/24  00:23:35  PAGE 11  

  653   1          dat00_flag[address] = 1;
  654   1      }
  655          
  656          
  657          
  658          
  659          
  660          u16 GET_SC()  //获取目前是调用0x0?0组标号
  661          {
  662   1          u16 dat =0;
  663   1          dat = (dat00[0x10] + 1) * 16;
  664   1          return dat;
  665   1      }
  666          
  667          u16 GET_SCdat() //获取目前是调用0x0?0组 的值（当前组寄存器个数）
  668          {
  669   1          return dat00[GET_SC()];
  670   1      }
  671          
  672          
  673          u16 GET_GBdat()   //获取目前是调用0x0?0组 的光标 的值
  674          {
  675   1          return dat00[GET_SC() + 0x0f];
  676   1      }
  677          
  678          u16 GET_SCdat3() //获取目前是调用0x0?0组 的 指向
  679          {
  680   1          return GET_GBdat() + 1 + GET_SC();
  681   1      }
  682          
  683          
  684          
  685          
  686          
  687          //========================================================================
  688          // 函数: u8 BCD_to_X10(u8 a)
  689          // 描述: 输入BCD格式的数据，返回普通格式的数据
  690          // 参数: 
  691          // 返回: 返回普通格式的数据
  692          // 版本: V1.0 2023.02.05
  693          //========================================================================
  694          u8 BCD_to_X10(u8 a)
  695          {
  696   1          a = (a / 16)*10 +(a%16);
  697   1          return a;
  698   1      }
  699          
  700          //========================================================================
  701          // 函数: u8 BCD_to_X10(u8 a)
  702          // 描述: 输入普通格式的数据，返回BCD格式的数据
  703          // 参数: 
  704          // 返回: 返回BCD格式的数据
  705          // 版本: V1.0 2023.02.05
  706          //========================================================================
  707          u8 X10_to_BCD(u16 a)
  708          {
  709   1          a = (a / 10)*16 + (a%10);
  710   1          return (u8)a;
  711   1      }
  712          
  713          
  714          //========================================================================
  715          // 函数: u8 GET_WEEK(u8 a)
  716          // 描述: 输入RTC读回的原始数据，返回星期
  717          // 参数: 
  718          // 返回: 返回星期
C251 COMPILER V5.60.0,  DATA                                                               25/04/24  00:23:35  PAGE 12  

  719          // 版本: V1.0 2023.02.05
  720          //========================================================================
  721          u8 GET_WEEK(u8 a)
  722          {
  723   1          u8 i=0;
  724   1          u8 b=0x01;
  725   1          for(i=0; i<8; i++)
  726   1          {
  727   2              if(a == b) break;
  728   2              b = b <<1;
  729   2          }
  730   1      
  731   1          return i;
  732   1      }
  733          //========================================================================
  734          // 函数: u8 GET_WEEK(u8 a)
  735          // 描述: 输入星期数据，返回RTC的星期格式
  736          // 参数: 
  737          // 返回: 返回RTC的星期格式
  738          // 版本: V1.0 2023.02.05
  739          //========================================================================
  740          u8 SET_WEEK(u16 a)
  741          {
  742   1          u8 i=0;
  743   1          u8 b=0x01;
  744   1      
  745   1          for(i=0; i<a; i++)
  746   1          {
  747   2              b = b <<1;
  748   2          }
  749   1      
  750   1          return b;
  751   1      }
  752          
  753          
  754          
  755          
  756          //========================================================================
  757          // 函数: void GET_time_c()
  758          // 描述: 获取时间的正常格式，进入修改时间会用到
  759          // 参数: 
  760          // 返回: 
  761          // 版本: V1.0 2023.02.05
  762          //========================================================================
  763          void GET_time_c()
  764          {
  765   1          u8 i = 0;
  766   1          dat00[0x0082] = BCD_to_X10(Time_New[0]);
  767   1          dat00[0x0083] = BCD_to_X10(Time_New[1]);
  768   1          dat00[0x0084] = BCD_to_X10(Time_New[2]);
  769   1          dat00[0x0086] = BCD_to_X10(Time_New[4]);
  770   1          dat00[0x0087] = BCD_to_X10(Time_New[5]);
  771   1          dat00[0x0088] = BCD_to_X10(Time_New[6]);
  772   1          dat00[0x0085] = GET_WEEK(Time_New[3]);
  773   1          for(i=0; i<7; i++)
  774   1          {
  775   2              dat00_low[0x0082+i] = dat00[0x0082+i];
  776   2          }
  777   1      }
  778          
  779          //========================================================================
  780          // 函数: void SET_time_c()
  781          // 描述: 将正常格式的时间转换为BCD码
  782          // 参数: 
  783          // 返回: 
  784          // 版本: V1.0 2023.02.05
C251 COMPILER V5.60.0,  DATA                                                               25/04/24  00:23:35  PAGE 13  

  785          //========================================================================
  786          void SET_time_c()
  787          {
  788   1          Time_int[0] = X10_to_BCD(dat00[0x0082]);
  789   1          Time_int[1] = X10_to_BCD(dat00[0x0083]);
  790   1          Time_int[2] = X10_to_BCD(dat00[0x0084]);
  791   1          Time_int[3] = SET_WEEK(dat00[0x0085]);
  792   1          Time_int[4] = X10_to_BCD(dat00[0x0086]);
  793   1          Time_int[5] = X10_to_BCD(dat00[0x0087]);
  794   1          Time_int[6] = X10_to_BCD(dat00[0x0088]);
  795   1          //dat00[0x0084] = GET_WEEK(Time_New[3]);
  796   1      }
  797          
  798          
  799          //========================================================================
  800          // 函数: u16 Date_restrictions1(u16 year,u16 moon,u16 day_addr,u16 max)
  801          // 描述: 输入年月，判断日是不是符合要求，如果不符合则强制修改
  802          // 参数: 
  803          // 返回: 
  804          // 版本: V1.0 2023.02.05
  805          //========================================================================
  806          u16 Date_restrictions1(u16 year,u16 moon,u16 day_addr,u16 max)
  807          {
  808   1          u16 num = 0;
  809   1          u16 add = 0;
  810   1          if(max == 0x0094) add = 5;
  811   1          if( (moon ==  4) ||  (moon ==  6) ||  (moon ==  9)||  (moon ==  11))
  812   1          {
  813   2              dat00_max[max] = 0x0014 + add;
  814   2              num = 30;
  815   2          }
  816   1          else if(moon ==  2)
  817   1          {
  818   2              if((year % 4) ==0)//闰年
  819   2              {
  820   3                  dat00_max[max] = 0x0015 + add;
  821   3                  num = 29;
  822   3              }
  823   2              else
  824   2              {
  825   3                  dat00_max[max] = 0x0016 + add;
  826   3                  num = 28;
  827   3              }
  828   2          }
  829   1          else
  830   1          {
  831   2              dat00_max[max] = 0x0013 + add;
  832   2              num = 31;
  833   2          }
  834   1          if( day_addr > num) day_addr = num;
  835   1          
  836   1          return day_addr;
  837   1      }
  838          
  839          
  840          
  841          
  842          
  843          
  844          
  845          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2405     ------
  ecode size           =    ------     ------
C251 COMPILER V5.60.0,  DATA                                                               25/04/24  00:23:35  PAGE 14  

  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       871     ------
  xdata-const size     =    ------     ------
  edata size           =      2066         14
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =      2992     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
